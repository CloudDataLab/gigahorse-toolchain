#ifndef NO_ANALYTICS
#include "decompiler_analytics.dl"
#endif

// All sorts of different outputs of the decompiler, including
// three-address code representation (which is later input and
// re-formatted for use by clients), statistics, debugging relations.

.output OpcodePossiblyHalts
.output Statement_Next

.decl InsBlockEdge(from: Block, to:Block)
.output InsBlockEdge

InsBlockEdge(from, to) :-
  BlockEdge(_, from, _, to).

.decl InsBlockJumpValidTarget(stmt:Block, target:Block)
.output InsBlockJumpValidTarget       

InsBlockJumpValidTarget(block, target) :-
  ReachableContext(ctx, block),
  BlockJumpValidTarget(ctx, block, _, target).

.decl InsensBlockInputContents(block:Block, index:number, var:Variable)

InsensBlockInputContents(block, index, var) :-
  BlockInputContents(_, block, index, var).

.output PublicFunctionEntry

/*
 ***********
 * Auxiliary relations: Dominance frontiers for optimal PHI instruction placement
 ***********
 */

// Both arguments are basic block heads
// There is a path from the entry to s that does not go through candidate
.decl DoesNotDominate(candidate:Block, s:Block)

DoesNotDominate(candidate, FUNCTION_SELECTOR) :-
  Statement_Block(_, candidate),
  candidate != FUNCTION_SELECTOR.

DoesNotDominate(candidate,s) :-
  DoesNotDominate(candidate,other),
  BlockEdge(_, s, _, other),
  s != candidate.

.decl Exit(block:Block)

Exit(block) :- Statement_Block(_, block), !BlockEdge(_, block, _, _).

// Both arguments are basic block heads
// There is a path from s to the exit that does not go through candidate
.decl DoesNotPostDominate(candidate: Block, s: Block)

DoesNotPostDominate(candidate, exitNode) :-
  Exit(exitNode),
  Statement_Block(_, candidate).

DoesNotPostDominate(candidate,s) :-
  DoesNotPostDominate(candidate,other),
  BlockEdge(_, other, _, s),
  s != candidate.

// The Dominates/PostDominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions would be expensive.
.decl Dominates(dominator:Block, s:Block)

Dominates(dominator,s) :-
  Statement_Block(_, dominator),
  Statement_Block(_, s),
  !DoesNotDominate(dominator,s).

.decl PostDominates(postdominator:Block, s:Block)
PostDominates(postdominator,s) :-
  Statement_Block(_, postdominator),
  Statement_Block(_, s),
  !DoesNotPostDominate(postdominator,s).

.decl DominatorFrontier(block: Block, frontier: Block)
// AFAIK a block f is a frontier of b if b dominates f
// but not f's predecessors

DominatorFrontier(block, frontier) :-
  Dominates(frontier, block),
  BlockEdge(_, pred, _, frontier),
  !Dominates(pred, block).


.decl PolymorphicStackIndex(block: Block, stackIndex: StackIndex)

PolymorphicStackIndex(block, stackIndex) :-
  FunctionalBlockInputContents(block, stackIndex, var1),
  FunctionalBlockInputContents(block, stackIndex, var2),
  var1 != var2.

.decl PHILocation(block: Block, stackIndex: StackIndex, newVarSymbol: symbol)

// Find all polymorphic stackIndexes
// These need phi instructions introduced at the dominance frontier
.output PHILocation
PHILocation(block, stackIndex, cat(cat(block, "_"), stackIndexStr)) :-
  PolymorphicStackIndex(block, stackIndex),
  Statement_Block(stmt, block),
  FunctionalStatement_Uses_Local(stmt, stackIndex, _),
  StackIndexToString(stackIndex, stackIndexStr).

.symbol_type TACVariable

// Final decompiler outputs
// VERY IMPORTANT: IF YOU CHANGE THESE, PLEASE ALSO CHANGE
// clientlogic/decompiler_inputs.dl 
.decl TAC_Op(stmt:Statement, op:Opcode)
.output TAC_Op             
.decl TAC_Stmt(stmt:Statement)
.output TAC_Stmt
.decl TAC_Use(stmt: Statement, var: TACVariable, i: number)
.output TAC_Use
.decl TAC_Def(stmt: Statement, var: TACVariable, n: number)
.output TAC_Def
.decl TAC_Var(var: TACVariable)
.output TAC_Var
.decl TAC_Block(stmt: Statement, block: Block)
.output TAC_Block
.decl TAC_Variable_Value(var: TACVariable, value: symbol)
.output TAC_Variable_Value
.decl TAC_Variable_Length(var: TACVariable, length: number)
.output TAC_Variable_Length

.decl CastStmtToTACVariableSymbol(x:symbol, y:symbol)
.decl CastStatementToTACVariable(s:Statement, v:TACVariable)
CastStmtToTACVariableSymbol(x,x) :- ValidStatement(x).
CastStmtToTACVariableSymbol(x,x) :- PHILocation(_, _, x).
CastStatementToTACVariable(x,y) :- CastStmtToTACVariableSymbol(x,y).

// Normal variable, known length
TAC_Variable_Value(tacvar, value) :-
   FunctionalStatement_Defines(stmt, var, _),
   CastStatementToTACVariable(stmt, tacvar),
   Variable_Value(var, value).

UnknownLength(var) :-
  (FunctionalStatement_Defines(stmt, var, _) ;
  FunctionalStatement_Uses(stmt, var, _)),
  !Variable_Length(var, _).

// Normal variable, unknown length
TAC_Variable_Length(tacvar, 32) :-
   (FunctionalStatement_Defines(stmt, var, _) ;
    FunctionalStatement_Uses(stmt, var, _)),
   CastStatementToTACVariable(stmt, tacvar),
   UnknownLength(var).

// phi variable, unknown length
TAC_Variable_Length(phiStmt, 32) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  UnknownLength(var).

TAC_Variable_Length(phiStmt, maxLength) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  maxLength = max length: Variable_Length(var, length),
  !UnknownLength(var).

// New Instructions
// *returnArgs = CALLPRIVATE(stmt, function, *args)
// *returnArgs = CALLPRIVATEI(cond, stmt, function, *args)
// RETURNPRIVATE(stmt, *args)

// Non-nop instructions
TAC_Stmt(stmt) :-
  ValidStatement(stmt),
  !TACNOP(stmt).

TAC_Op(stmt, op) :-
   Statement_Opcode(stmt, op),
   ValidStatement(stmt),
   !TACNOP(stmt),
   !FunctionCallStmt(stmt),
   !FunctionReturnStmt(stmt),
   !ThrowJump(stmt),
   !PushValue(stmt, _).


TAC_Op(stmt, "CONST") :-
   PushValue(stmt, _).

TAC_Op(stmt, "CALLPRIVATEI") :-
   JUMPI(stmt),
   FunctionCallStmt(stmt).

TAC_Op(stmt, "CALLPRIVATE") :-
   JUMP(stmt),
   FunctionCallStmt(stmt).

TAC_Op(stmt, "RETURNPRIVATEI") :-
   JUMPI(stmt),
   FunctionReturnStmt(stmt).

TAC_Op(stmt, "RETURNPRIVATE") :-
   JUMP(stmt),
   FunctionReturnStmt(stmt).

TAC_Op(stmt, "THROW") :-
   JUMP(stmt),
   ThrowJump(stmt).

TAC_Op(stmt, "THROWI") :-
   JUMPI(stmt),
   ThrowJump(stmt).

TAC_Op(stmt, op) :-
   FunctionReturnStmt(stmt),
   Statement_Opcode(stmt, op),
   ValidStatement(stmt),
   !JUMP(stmt),
   !JUMPI(stmt).
   
// Phi instructions
TAC_Var(tacvar),
TAC_Def(stmt, tacvar, 0),
TAC_Stmt(stmt),
TAC_Op(stmt, "PHI") :-
  PHILocation(_, _, stmt),
  CastStatementToTACVariable(stmt, tacvar).

// Non-phi, non-call variable id same as stmt it is defined in
TAC_Var(var_rep),
TAC_Def(stmt, var_rep, n) :-
   FunctionalStatement_Defines(stmt, var, n),
   Variable_String(var, var_rep).

// Case 1: Uses locally defined variable
TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, var, n),
  CheckIsVariable(var),
  Variable_String(var, var_rep).

// Case 2: Uses monomorphic global var
TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, stackIndex, n),
  CheckIsStackIndex(stackIndex),
  Statement_Block(stmt, block),
  !PolymorphicStackIndex(block, stackIndex),
  FunctionalBlockInputContents(block, stackIndex, var),
  Variable_String(var, var_rep).

// Case 3: Is a PHI statement
TAC_Use(phiStmt, var_rep, -1) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  Variable_String(var, var_rep).

// Case 4: Uses polymorphic variable
TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, stackIndex, n),
  CheckIsStackIndex(stackIndex),
  Statement_Block(stmt, block),
  PHILocation(block, stackIndex, var_rep).

TAC_Block(stmt, block) :-
  Statement_Block(stmt, block),
  !TACNOP(stmt).

TAC_Block(phiStmt, block) :-
  PHILocation(block, _, phiStmt).
//   DominatorFrontier([block], [frontier]).



/***********
 *  Function-discovery outputs to visualization scripts
 ***********/

.output FunctionCall
.output FunctionCallReturn
.output Function_Return
.output Function

.decl FormalArgs(func:Block, var:symbol, n:number)
.output FormalArgs

FormalArgs(func, var_rep, n) :-
   FunctionArgument(func, n, var),
   Variable_String(var, var_rep).

.decl ActualReturnArgs(caller:Block, var_rep:symbol, n:number)
.output ActualReturnArgs

ActualReturnArgs(caller, var_rep, n) :-
   FunctionCallReturnArgument(caller, n, var),
   Variable_String(var, var_rep).

.output LocalBlockEdge
.output HighLevelFunctionName
.output FallthroughEdge

.output Mask_Length        


