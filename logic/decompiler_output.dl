// VERY IMPORTANT: IF YOU CHANGE ANY OUTPUT RELATION IN THIS FILE,
// PLEASE ALSO CHANGE clientlib/decompiler_imports.dl

// All sorts of different outputs of the decompiler, including
// three-address code representation (which is later input and
// re-formatted for use by clients), statistics, debugging relations.


// useful intermediate outputs
.output OpcodePossiblyHalts
.output IRBlockEdge
.output PublicFunction
.output Statement_IRStatement
.output IRBlock_Gas

.decl Exit(block:IRBlock)

Exit(block) :- IRStatement_Block(_, block), !IRBlockEdge(block, _).

.decl FunctionalBlock_Uses_Local(block: IRBlock, stackIndex: StackIndex)

FunctionalBlock_Uses_Local(block, stackIndex) :-
  IRStatement_Block(stmt, block),
  FunctionalStatement_Uses_Local(stmt, stackIndex, _),
  IsStackIndex(stackIndex).

.decl DoesNotDominate(dominator: IRBlock, block: IRBlock)
DoesNotDominate(block, entry) :-
  IRInFunction(block, entry),
  block != entry.

DoesNotDominate(block, block2) :-
  DoesNotDominate(block, other),
  LocalBlockEdge(other, block2),
  block != block2.

.decl Dominates(block1: IRBlock, block2: IRBlock)

Dominates(dominator, block) :-
  IRInFunction(dominator, entry),
  IRInFunction(block, entry),
  !DoesNotDominate(dominator, block).

.decl StrictlyDominates(block1: IRBlock, block2: IRBlock)

StrictlyDominates(dominator, block) :-
  Dominates(dominator, block),
  dominator != block.

.decl DominanceFrontier(dBlock: IRBlock, block: IRBlock)

DominanceFrontier(dBlock, block) :-
  LocalBlockEdge(pred, block),
  Dominates(dBlock, pred),
  !StrictlyDominates(dBlock, block).

.decl DFPlus(dBlock: IRBlock, block: IRBlock, rep: Variable)
.output DFPlus

DFPlus(dBlock, block, rep) :-
  FunctionalBlockDefines_Local(dBlock, rep),
  DominanceFrontier(dBlock, block).

DFPlus(dBlock, block, rep) :-
  DFPlus(dBlock, other, rep),
  DominanceFrontier(other, block).

.decl PhiRep(var: symbol, rep: Variable)

PhiRep(phiVar, repVar),
PHILocation(block, stackIndex, phiVar) :-
  DFPlus(_, block, repVar),
  MayPlacePhi(block, stackIndex, repVar),
  NumberToString(stackIndex, stackIndexStr),
  phiVar = cat(cat(block, "_"), stackIndexStr).


.decl FunctionalBlockDefines_Local(block: IRBlock, variable: Variable)

FunctionalBlockDefines_Local(block, rep) :-
  FunctionalStatement_Defines(stmt, var, _),
  IRStatement_Block(stmt, block),
  VarRepresentative(var, rep).

.decl VarRepresentative(var: Variable, representative: Variable)
.output VarRepresentative

VarRepresentative(var, representative) :-
  PolymorphicVar(var, func),
  representative = min rep : EquivalentVars(func, var, rep).

.decl EquivalentVars(func: IRBlock, var: Variable, representative: Variable)

// Reflexivity
EquivalentVars(func, var, var) :-
  FunctionalStatement_Defines(stmt, var, _),
  IRStatement_Block(stmt, block),
  IRInFunction(block, func).

.decl MayPlacePhi(block: IRBlock, stackIndex: StackIndex, representative: Variable)
.decl PolymorphicVar(var: Variable, func: IRBlock)

PolymorphicVar(var1, func),
PolymorphicVar(var2, func),
EquivalentVars(func, var1, var2) :-
  FunctionalBlockInputContents(block, stackIndex, var1),
  FunctionalBlockInputContents(block, stackIndex, var2),
  IRInFunction(block, func),
  var1 != var2.

MayPlacePhi(block, stackIndex, representative) :-
  FunctionalBlockInputContents(block, stackIndex, var1),
  FunctionalBlockInputContents(block, stackIndex, var2),
  VarRepresentative(var1, representative),
  var1 != var2.

.decl PolymorphicStackIndex(block: IRBlock, stackIndex: StackIndex)

PolymorphicStackIndex(block, stackIndex) :-
  FunctionalBlock_Uses_Local(block, stackIndex),
  FunctionalBlockInputContents(block, stackIndex, var1),
  FunctionalBlockInputContents(block, stackIndex, var2),
  var1 != var2.

.decl PHILocation(block: IRBlock, stackIndex: StackIndex, newVarSymbol: symbol)
.output PHILocation

// Find all polymorphic stackIndexes
// These need phi instructions introduced at the dominance frontier
//PHILocation(block, stackIndex, cat(cat(block, "_"), stackIndexStr)) :-
//  PolymorphicStackIndex(block, stackIndex),
//  NumberToString(stackIndex, stackIndexStr).

.symbol_type TACVariable

// Final decompiler outputs
.decl TAC_Op(stmt:IRStatement, op:Opcode)
.output TAC_Op
.decl TAC_Stmt(stmt:IRStatement)
.output TAC_Stmt
.decl PRE_TAC_Use(stmt: IRStatement, var: TACVariable, i: number)
.decl TAC_Use(stmt: IRStatement, var: TACVariable, i: number)
.output TAC_Use
.decl TAC_Def(stmt: IRStatement, var: TACVariable, n: number)
.output TAC_Def
.decl TAC_Var(var: TACVariable)
.output TAC_Var
.decl TAC_Block(stmt: IRStatement, block: IRBlock)
.output TAC_Block
.decl TAC_Block_Head(block: IRBlock, stmt: IRStatement)
.output TAC_Block_Head
.decl TAC_Variable_Length(var: TACVariable, length: number)
.output TAC_Variable_Length
.decl TAC_Variable_Value(var: TACVariable, value: symbol)
.output TAC_Variable_Value
.decl TAC_Variable_BlockValue(var: TACVariable, value: symbol)
.output TAC_Variable_BlockValue


/// Heuristically change the values of all constants that match cloned
/// basic block labels! Don't up

TAC_Variable_BlockValue(tacvar, irvalue) :-
  FunctionalStatement_Defines(stmt, var, _),
  Variable_Stmt_String(var, stmt, tacvar),
  Variable_Value(var, value),
  StatementAndBlockInSameFunction(stmt, CAST_TO_SYMBOL(value), irvalue),
   // value matches address of block
  substr(value, 0, 2) = "0x".

.decl StatementAndBlockInSameFunction(stmt: IRStatement, block: Block, irblock: IRBlock)
StatementAndBlockInSameFunction(stmt, block, irblock) :-
  Statement_IRStatement(_, func, stmt),
  Block_IRBlock(block, func, irblock).


// Normal variable, known length
TAC_Variable_Value(tacvar, value) :-
   FunctionalStatement_Defines(stmt, var, _),
   Variable_Stmt_String(var, stmt, tacvar),
   Variable_Value(var, value),
   substr(value, 0, 2) = "0x".

UnknownLength(var) :-
  (FunctionalStatement_Defines(stmt, var, _) ;
  FunctionalStatement_Uses(stmt, var, _)),
  !Variable_Length(var, _).

// Normal variable, unknown length
TAC_Variable_Length(tacvar, 32) :-
   (FunctionalStatement_Defines(stmt, var, _) ;
    FunctionalStatement_Uses(stmt, var, _)),
   Variable_Stmt_String(var, stmt, tacvar),
   UnknownLength(var).

// phi variable, unknown length
TAC_Variable_Length(phiStmt, 32) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  UnknownLength(var).

TAC_Variable_Length(phiStmt, maxLength) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  maxLength = max length: Variable_Length(var, length),
  !UnknownLength(var).

// New Instructions
// *returnArgs = CALLPRIVATE(stmt, function, *args)
// *returnArgs = CALLPRIVATEI(cond, stmt, function, *args)
// RETURNPRIVATE(stmt, *args)

// Non-nop instructions
TAC_Stmt(irstmt) :-
  Statement_IRStatement(stmt, _, irstmt),
  ValidStatement(stmt),
  !IRTACNOP(stmt).

TAC_Op(irstmt, op) :-
   IRStatement_Opcode(irstmt, op),
   Statement_IRStatement(stmt, _, irstmt),
   ValidStatement(stmt),
   !IRTACNOP(irstmt),
   !ThrowJump(stmt),
   !PushValue(stmt, _),
   !PC(stmt),
   !REVERT(stmt),
   !INVALID(stmt).

TAC_Op(irstmt, "CONST") :-
   Statement_IRStatement(stmt, _, irstmt),
   (PushValue(stmt, _) ; PC(stmt)).

TAC_Op(irstmt, "THROW") :-
   Statement_IRStatement(stmt, _, irstmt),
   JUMP(stmt),
   ThrowJump(stmt).

TAC_Op(irstmt, "THROW") :-
   Statement_IRStatement(stmt, _, irstmt),
   (INVALID(stmt) ; REVERT(stmt)).

TAC_Op(irstmt, "THROWI") :-
   Statement_IRStatement(stmt, _, irstmt),
   JUMPI(stmt),
   ThrowJump(stmt).

// Phi instructions
TAC_Var(CAST_TO_SYMBOL(stmt)),
TAC_Def(stmt, CAST_TO_SYMBOL(stmt), 0),
TAC_Stmt(stmt),
TAC_Op(stmt, "PHI") :-
  PHILocation(_, _, stmt).

// Non-phi, non-call variable id same as stmt it is defined in
TAC_Var(var_rep),
TAC_Def(stmt, var_rep, n) :-
   FunctionalStatement_Defines(stmt, var, n),
  Variable_Stmt_String(var, stmt, var_rep).

// Case 1: Uses locally defined variable
PRE_TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, var, n),
  CheckIsVariable(var),
  Variable_Stmt_String(var, stmt, var_rep).

// Case 2: Uses monomorphic global var
// Using the block in which the var is defined,
// Fixes cases where a stmt in a cloned block is using
// a variable defined in a non cloned block
PRE_TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, stackIndex, n),
  CheckIsStackIndex(stackIndex),
  IRStatement_Block(stmt, block),
  IRInFunction(block, fun),
  !PolymorphicStackIndex(block, stackIndex),
  // !PHILocation(block, stackIndex, _),
  FunctionalBlockInputContents(block, stackIndex, var),
  FunctionalStatement_Defines(defstmt, var, _),
  IRStatement_Block(defstmt, defBlock),
  IRInFunction(defBlock, fun),
  Variable_Block_String(var, defBlock, var_rep).

//Case 2.1: Uses arg(like the above case, but not defined)
PRE_TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, stackIndex, n),
  CheckIsStackIndex(stackIndex),
  IRStatement_Block(stmt, block),
  !PHILocation(block, stackIndex, _),
  FunctionalBlockInputContents(block, stackIndex, var),
  FunctionArgument(_, _, var),
  Variable_String(var, var_rep).


// Case 3: Is a PHI statement
PRE_TAC_Use(phiStmt, var_rep, -1) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  IRInFunction(block, fun),
  FunctionalStatement_Defines(defstmt, var, _),
  IRStatement_Block(defstmt, defBlock),
  IRInFunction(defBlock, fun),
  Variable_Block_String(var, defBlock, var_rep).

// Case 3.1: Phis using args
PRE_TAC_Use(phiStmt, var_rep, -1) :-
  PHILocation(block, stackIndex, phiStmt),
  FunctionalBlockInputContents(block, stackIndex, var),
  FunctionArgument(_, _, var),
  Variable_String(var, var_rep).


TAC_Use(stmt, var_rep, n) :-
   !IRThrowJump(stmt),
   PRE_TAC_Use(stmt, var_rep, n).

TAC_Use(irstmt, var_rep, n-1) :-
   IRThrowJump(irstmt),
   PRE_TAC_Use(irstmt, var_rep, n),
   n > 0.


// Case 4: Uses polymorphic variable
PRE_TAC_Use(stmt, phi_var, n) :-
  FunctionalStatement_Uses_Local(stmt, stackIndex, n),
  CheckIsStackIndex(stackIndex),
  IRStatement_Block(stmt, block),
  PolymorphicStackIndex(block, stackIndex),
  FunctionalBlockInputContents(block, stackIndex, polyVar),
  VarRepresentative(polyVar, varRep),
  Dominates(dom, block),
  PHILocation(dom, _, phi_var),
  PhiRep(phi_var, varRep).

TAC_Block(stmt, block) :-
  IRStatement_Block(stmt, block),
  !IRTACNOP(stmt).

TAC_Block(phiStmt, block) :-
  PHILocation(block, _, phiStmt).


// Fresh call statements
//TAC_Block(callStmt, block) :-
//   BasicBlock_CALL(block, callStmt).


/***********
 *  Function-discovery outputs to visualization scripts
 ***********/

.output IRFunctionCall
.output IRFunctionCallReturn
.output IRFunction_Return
.output IsFunctionEntry(IO="file", filename="Function.csv", delimiter="\t")

.decl FormalArgs(func:IRFunction, var:symbol, n:number)
.output FormalArgs

FormalArgs(func, var_rep, n) :-
   FunctionArgument(func, n, var),
   Variable_String(var, var_rep).

.decl ActualReturnArgs(caller:IRBlock, var_rep:symbol, n:number)
.output ActualReturnArgs

ActualReturnArgs(caller, var_rep, n) :-
   FunctionCallReturnArgument(caller, n, var),
   Variable_Block_String(var, caller, var_rep).

.output LocalBlockEdge
.output HighLevelFunctionName
.output IRFallthroughEdge

.output Mask_Length
.output IRInFunction(IO="file", filename="InFunction.csv", delimiter="\t")
.output IRFunctionEntry

/*****
 *  Statement Ordering
 *****/
.decl PRE_TAC_Statement_Next(stmt: Statement, next: Statement)

PRE_TAC_Statement_Next(stmt, next) :-
   Statement_Next(stmt, next).

PRE_TAC_Statement_Next(stmt, nextnext) :-
  PRE_TAC_Statement_Next(stmt, next),
  PRE_TAC_Statement_Next(next, nextnext),
  TACNOP(next).


/// WARNING: This only works intra-procedurally after the Functional IR conversion.
.decl TAC_Statement_Next(stmt: IRStatement, next: IRStatement)
.output TAC_Statement_Next

TAC_Statement_Next(irstmt, irnext) :-
   PRE_TAC_Statement_Next(stmt, next),
   Statement_IRStatement(stmt, func, irstmt),
   Statement_IRStatement(next, func, irnext),
   TAC_Block(irstmt, _), TAC_Block(irnext, _).

// TODO for statement ordering
// a) phi functions
// b) fresh call statements (if reintroduced)

TAC_Block_Head(block, irstmt) :-
   TAC_Block(irstmt, block),
   Statement_IRStatement(stmt, _, irstmt),
   IsBasicBlockHead(stmt).


/******
 * Event signatures
 *****/

.decl EventSignature(hex_signature: Value, text_signature: symbol)
.input EventSignature

.decl EventSignatureInContract(hex_signature: Value, text_signature: symbol)
.output EventSignatureInContract

.decl LOGStmt_SigHash(log:IRStatement, sigHash:symbol)
//.output LOGStmt_SigHash

LOGStmt_SigHash(stmt, sigHash):-
  (TAC_Op(stmt, "LOG0");
  TAC_Op(stmt, "LOG1");
  TAC_Op(stmt, "LOG2");
  TAC_Op(stmt, "LOG3");
  TAC_Op(stmt, "LOG4")),
  TAC_Use(stmt, logSigHashVar, 2),
  TAC_Variable_Value(logSigHashVar, sigHash).

EventSignatureInContract(sigHash, sigText):-
  LOGStmt_SigHash(_, sigHash),
  EventSignature(sigHash, sigText).


.decl ConstantPossibleSigHash(constSigHash:symbol, name:symbol)
.output ConstantPossibleSigHash

ConstantPossibleSigHash(sigHashBigVal, name):-
  TAC_Variable_Value(_, sigHashBigVal),
  sigHash = substr(sigHashBigVal, 0 , 10),
  PublicFunctionSignature(sigHash, name).
