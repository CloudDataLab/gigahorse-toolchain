/*
 * Preprocessing of decompiler input, to yield convenient relations
 */

#include "decompiler_inputs.dl"

.type Opcode
.type Statement 

.decl Statement_Opcode(statement: Statement, opcode: Opcode)
.input Statement_Opcode

.decl Statement_Next(statement: Statement, statementNext: Statement)
.input Statement_Next

// Any input opcode that should not be present in the output
// (three-address) code. These are mostly stack machine instructions,
// which disappear. Other instructions (e.g., logical or arithmetic
// operators) are maintained in the output but arguments are inferred.
// Similarly, instructions can disappear from the output (e.g., a JUMP
// may become a PRIVATECALL) but this is a property of an instance, not
// the entire JUMP opcode.
.decl TACNOP(statement: Statement)

TACNOP(stmt) :-
  Statement_Opcode(stmt, opcode),
  (OpcodeIsDup(opcode) ; OpcodeIsSwap(opcode)).

TACNOP(stmt) :- POP(stmt) ; JUMPDEST(stmt).

.decl MissingStatement(stmt: Statement)

MissingStatement(stmt) :-
  Statement_Opcode(stmt, "MISSING").

.decl PushValue(stmt:Statement, v:Value)
.input PushValue

.decl IsJump(stmt:Statement)

IsJump(stmt) :-
  (JUMP(stmt); JUMPI(stmt)).

IsValue(v) :-
   PushValue(_, v).

IsValue(CAST_TO_SYMBOL(v)) :-
  PC(v).

.decl DynamicStatement(stmt:Statement)
DynamicStatement(stmt) :-
  ADDRESS(stmt); BALANCE(stmt); BLOCKHASH(stmt); CALL(stmt); CALLCODE(stmt); STATICCALL(stmt);
  CALLDATALOAD(stmt);  CALLDATASIZE(stmt); CALLER(stmt); CALLVALUE(stmt); CODESIZE(stmt);
  COINBASE(stmt); CREATE(stmt); DELEGATECALL(stmt); DIFFICULTY(stmt);
  EXTCODESIZE(stmt); GAS(stmt); GASLIMIT(stmt); GASPRICE(stmt); NUMBER(stmt);
  ORIGIN(stmt); RETURNDATASIZE(stmt); TIMESTAMP(stmt); SHA3(stmt).
// CALLDATACOPY and CODECOPY don't leave anything on the stack.
// GAS is not an environmental instruction, but it's still dynamic.
// RETURNDATASIZE is a new instruction, not in the Yellow Paper.
// Represents stack contents at previous location in the same block

// Many operations have neutral elements, and some are used often.
// Recognize such arithmetic that is guaranteed to return one of its
// operands.
.decl OperationIsEq(opcode:symbol, value:Value)
.decl OperationIs(opcode:symbol, value1:Value, value2:Value)

OperationIsEq("OR", "0x0").
OperationIsEq("SHL", "0x0").
OperationIsEq("SHR", "0x0").
OperationIsEq("SAR", "0x0").
OperationIsEq("XOR", "0x0").
OperationIsEq("ADD", "0x0").
OperationIsEq("SUB", "0x0").
OperationIsEq("MUL", "0x1").
OperationIsEq("DIV", "0x1").
OperationIsEq("SDIV", "0x1").
OperationIsEq("AND", mask) :- Mask_Length(mask, length), length > 0. 

// Masks with all 1s
.decl Mask_Length(mask: Value, bytes: number)
.decl PreMask_Length(mask: symbol, bytes: number)

Mask_Length(cat("0x", mask), bytes) :-
   PreMask_Length(mask, bytes).

PreMask_Length("1", 1).
PreMask_Length("3", 1).
PreMask_Length("7", 1).
PreMask_Length("f", 1).
PreMask_Length("1f", 1).
PreMask_Length("3f", 1).
PreMask_Length("7f", 1).
PreMask_Length("ff", 1).

PreMask_Length(cat("ff", mask), bytes+1) :-
  PreMask_Length(mask, bytes),
  bytes < 32.

OperationIs("AND", "0x0", "0x0").
OperationIs("MUL", "0x0", "0x0").
OperationIs("AND", "0xffffffffffffffffffffffff0000000000000000000000000000000000000000", "ADDRESS").

.decl DUPN(opcode:Opcode, n:number)

DUPN(opcode, dupn - dup1 + 1) :-
  OpcodeOrd(opcode, dupn),
  OpcodeIsDup(opcode),
  OpcodeOrd("DUP1", dup1).

.decl SWAPN(opcode:Opcode, n:number)

SWAPN(opcode, swapn - swap1 + 1) :-
  OpcodeOrd(opcode, swapn),
  OpcodeIsSwap(opcode),
  OpcodeOrd("SWAP1", swap1).

.decl IsSmallNumber(n:number)
      
IsSmallNumber(0).

IsSmallNumber(n+1) :-
  IsSmallNumber(n),
  n+1 < 0xFFF.

.decl NumberToString(a:StackIndex, s: symbol)

NumberToString(0, "0").
NumberToString(1, "1").
NumberToString(2, "2").
NumberToString(3, "3").
NumberToString(4, "4").
NumberToString(5, "5").
NumberToString(6, "6").
NumberToString(7, "7").
NumberToString(8, "8").
NumberToString(9, "9").
NumberToString(10, "a").
NumberToString(11, "b").
NumberToString(12, "c").
NumberToString(13, "d").
NumberToString(14, "e").
NumberToString(15, "f").

NumberToString(n, cat(rst, head)) :-
  IsSmallNumber(n),
  n > 15,
  NumberToString(n / 16, rst),
  NumberToString(n % 16, head).

OpcodePopWords("CALLPRIVATE", 1).
OpcodePopWords("RETURNPRIVATE", 1).
OpcodePopWords("CALLPRIVATEI", 2).
OpcodePopWords("RETURNPRIVATEI", 2).