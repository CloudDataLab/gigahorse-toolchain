// The core of the decompiler logic. Most complex reasoning for value
// flow and detecting CFG edges (much like the Vandal decompiler) is here.

#define MAX_STACK_HEIGHT 50
#define CAST_TO_SYMBOL(b) cat("", (b))
#define CheckIsVariable(v) ((v) < 0)
#define CheckIsStackIndex(v) ((v) >= 0, (v) < MAX_STACK_HEIGHT)
#define FUNCTION_SELECTOR "0x0"

#include "N-Call-Context.dl"
//#include "selective_Ncontext+.dl"
#include "decompiler_instructions.dl"
#include "functions.dl"
#include "decompiler_output.dl"
#ifndef NO_ANALYTICS
#include "decompiler_analytics.dl"
#endif


.type Block 
.type Value
.number_type Variable
.number_type StackIndex
.type VariableOrStackIndex = Variable | StackIndex


.decl Variable_Value(variable: Variable, value: Value)

.decl IsVariable(n:Variable)

// One to one mapping. Give every statement a unique var (negative index)
.decl Statement_Defines(statement: Statement, variable: Variable)

.decl _StatementNum(statement: Statement, num: number)

_StatementNum(stmt, -n-1) :-
   NumberToString(n, stmt).


// We pre-assign variables to every statement except if they are
// not really creating new values on the stack (e.g. no pushes or simple swaps)
IsVariable(n),
Statement_Defines(stmt, n) :-
  _StatementNum(stmt, n),
  Statement_Opcode(stmt, opcode),
  OpcodePushWords(opcode, m), m > 0,
  !TACNOP(stmt).

.decl IsStackIndex(n:StackIndex)
      
IsStackIndex(0).

IsStackIndex(n+1) :-
  IsStackIndex(n),
  n+1 < MAX_STACK_HEIGHT.

// Convenience predicate. Folds together bounds checking on valid
// indices and less-than.
.decl IsStackIndexLessThan(n:StackIndex, maximum:StackIndex) inline
                                                             
IsStackIndexLessThan(n, maximum) :-
  IsStackIndex(maximum),
  IsStackIndex(n),
  n < maximum.
 
.decl IsValue(v:Value)
               
/*
 ***********
 * Define basic blocks
 ***********
 */
 
// Textbook material.
// A basic block starts:
//   - at a label
//   - after a jump.
// A basic block ends:
//   - at a jump
//   - before a label.
.decl IsBasicBlockHead(statement:Statement)
IsBasicBlockHead(statement) :-
  JUMPDEST(statement).

IsBasicBlockHead(statement) :-
  JUMPI(prevStatement),
//// REVIEW: check that this is equivalent
//  Statement_Opcode(prevStatement, opcode),
//  OpcodeAltersFlow(opcode),
  Statement_Next(prevStatement, statement).

IsBasicBlockHead(statement) :-
  Statement_Opcode(statement, _),
  !Statement_Next(_, statement).  

// Heuristic to separate code from data:
// Anything in a basic block after an instruction that alters flow or
// an invalid opcode is data.
.decl PossiblyIsBasicBlockTail(statement:Statement)

PossiblyIsBasicBlockTail(statement) :-
  Statement_Opcode(statement, opcode),
  OpcodeAltersFlow(opcode).

PossiblyIsBasicBlockTail(statement) :-
  Statement_Next(statement, labelstatement),
  JUMPDEST(labelstatement).

PossiblyIsBasicBlockTail(statement) :-
  MissingStatement(statement).

.decl Statement_Block(statement:Statement, block:Block)
.decl Statement_BlockHead(statement:Statement, head:Statement)

Statement_BlockHead(stmt, stmt),
Statement_Block(stmt, CAST_TO_SYMBOL(stmt)) :-
  IsBasicBlockHead(stmt).

Statement_BlockHead(stmt, CAST_TO_SYMBOL(block)),
Statement_Block(stmt, block) :-
  Statement_Block(prevstmt, block),
  Statement_Next(prevstmt, stmt),
  !IsBasicBlockHead(stmt),
  !PossiblyIsBasicBlockTail(prevstmt).

.decl BasicBlock_Tail(block:Block, tail:Statement)

BasicBlock_Tail(block, tail) :-
   Statement_Block(tail, block),
   Statement_Next(tail, next),
   !Statement_Block(next, block).

BasicBlock_Tail(block, tail) :-
   Statement_Block(tail, block),
   !Statement_Next(tail, _).

.decl ValidStatement(stmt: Statement)

ValidStatement(stmt) :- Statement_Block(stmt, _).

.decl Block_PartialGas(block: Block, stmt: Statement, gas: number)
Block_PartialGas(block, stmt, gas) :-
  Statement_Block(stmt, block),
  Statement_Gas(stmt, gas).

.decl Block_Gas(block: Block, gas: number)
   
Block_Gas(block, totalgas) :-
   Statement_Block(_, block),
   totalgas = sum gas : Block_PartialGas(block, _, gas).

/*
 ***********
 * Key definitions
 ***********
 */
 

// Stack contents at input and output of a block, given its calling context.
.decl BlockOutputContents(context:Context, block:Block, index:StackIndex, var:Variable)
.decl BlockInputContents(context:Context, block:Block, index:StackIndex, var:Variable)

// Var holding the (target block) address a block jumps to, under context.
.decl BlockJumpTarget(context:Context, block:Block, var:Variable)

// The target of a jump at the end of the block is a variable defined in
// the block itself. "Immediate" is misnomer, can't think of better name.
// This is a context-independent predicate.
.decl ImmediateBlockJumpTarget(block:Block, var:Variable)

// A summary of all the effects of the basic block up to a statement. The
// summary cannot contain only variables, it will also refer symbolically to
// other locations (stackIndexes) on the stack at the beginning of the basic block.
.decl LocalStackContents(stmt:Statement, index:StackIndex, variable:VariableOrStackIndex)

.decl BeforeLocalStackContents(stmt:Statement, n:StackIndex, variable:VariableOrStackIndex)

.decl BlockEdge(callerCtx:Context, caller:Block, calleeCtx:Context, callee:Block)
.decl ReachableContext(ctx:Context, block:Block)

// How many items the basic block will pop from the stack that existed at
// the beginning of its execution. I.e., how many items it will consume
// from its caller. This is a high-watermark kind of measure: the consumed
// data items may be replenished during execution, but we care about how high
// the total will go.
.decl BlockPopDelta(block:Block, delta:StackIndex)

// What is the difference in stack height effected by the basic block
.decl BlockStackDelta(block:Block, delta:StackIndex)

// Same for the effects up to a statement, since the beginning of the
// containing basic block.
.decl StatementPopDelta(statement:Statement, delta:StackIndex)
.decl StatementStackDelta(statement:Statement, delta:StackIndex)

/*
 ***********
 * Define block's behavior based on constituents
 ***********
 */

BlockInputContents(calleeCtx, callee, index, variable) :-
  BlockOutputContents(callerCtx, caller, index, variable),
  BlockEdge(callerCtx, caller, calleeCtx, callee).
  .plan 1:(2,1)
      
// Copy the stack variables untouched by the callee basic block
BlockOutputContents(calleeCtx, callee, index+delta, variable) :-
  BlockInputContents(calleeCtx, callee, index, variable),
  index >= calleePopLen,
  index+delta <= MAX_STACK_HEIGHT,
  BlockPopDelta(callee, calleePopLen),
  BlockStackDelta(callee, delta).

// Handle the proper variables pushed by this basic block
BlockOutputContents(ctx, block, index, var) :-
  ReachableContext(ctx, block),
  BasicBlock_Tail(block, stmt),
  LocalStackContents(stmt, index, var),
  CheckIsVariable(var).

// Handle the stackIndexes pushed by this basic block
BlockOutputContents(ctx, block, index, realVariable) :-
  BlockInputContents(ctx, block, stackIndex, realVariable),
  BasicBlock_Tail(block, stmt),
  LocalStackContents(stmt, index, stackIndex),
  CheckIsStackIndex(stackIndex).

ImmediateBlockJumpTarget(block, var) :-
  BasicBlock_Tail(block, stmt),
  IsJump(stmt),
  BeforeLocalStackContents(stmt, 0, var),
  CheckIsVariable(var).

BlockJumpTarget(ctx, block, var) :-
  ReachableContext(ctx, block),
  ImmediateBlockJumpTarget(block, var).

BlockJumpTarget(ctx, block, realVariable) :-
  BlockInputContents(ctx, block, stackIndex, realVariable),
  CheckIsStackIndex(stackIndex),
  BasicBlock_Tail(block, stmt),
  IsJump(stmt),
  BeforeLocalStackContents(stmt, 0, stackIndex).

.decl ThrowJump(stmt:Statement)

ThrowJump(jmp) :-
   ImmediateBlockJumpTarget(block, variable),
   Variable_Value(variable, targetValue),
   !JUMPDEST(CAST_TO_SYMBOL(targetValue)),
   BasicBlock_Tail(block, jmp).

// Under ctx, the block's tail will jump to the value of "variable", which
// is equal to the label of "target" block.
.decl BlockJumpValidTarget(ctx:Context, block:Block, variable: Variable, target:Block)

BlockJumpValidTarget(ctx, block, targetVar, CAST_TO_SYMBOL(targetValue)) :-
  BlockJumpTarget(ctx, block, targetVar),
  Variable_Value(targetVar, targetValue),
  JUMPDEST(CAST_TO_SYMBOL(targetValue)).

/*
 ***********
 * Define semantics of instructions
 ***********
 */
// Variables unaffected by this instruction.
// Pop is modeled as a side-effect!
LocalStackContents(stmt, n + delta, varOrStackIndex) :-
  BeforeLocalStackContents(stmt, n, varOrStackIndex),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, delta),
  OpcodePopWords(opcode, numRemoved),
  n >= numRemoved.

// Base case, handles most cases
LocalStackContents(stmt, 0, var) :-
  Statement_Defines(stmt, var),
  !TACNOP(stmt).

// Constant values. Example of implementation of push1 to push32.
Variable_Value(var, value) :-
  PushValue(stmt, value),
  Statement_Defines(stmt, var).

// Get current program counter
Variable_Value(var, CAST_TO_SYMBOL(stmt)) :-
  PC(stmt),
  Statement_Defines(stmt, var).

.decl ArithmeticOpcodes(stmt:Statement, var0:VariableOrStackIndex, var1:VariableOrStackIndex, res:Variable)

ArithmeticOpcodes(stmt, var0, var1, res) :-
  Statement_Opcode(stmt, opcode),
  OpcodeIsArithmetic(opcode),
  BeforeLocalStackContents(stmt, 0, var0),
  BeforeLocalStackContents(stmt, 1, var1),
  Statement_Defines(stmt, res).

Variable_Value(resVar, val1) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  Statement_Opcode(stmt, opcode),
  Variable_Value(var0, val0),
  Variable_Value(var1, val1),
  OperationLeftIdentity(opcode, val0).

Variable_Value(resVar, val0) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  Statement_Opcode(stmt, opcode),
  Variable_Value(var0, val0),
  Variable_Value(var1, val1),
  OperationRightIdentity(opcode, val1).

Variable_Value(resVar, res) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  Statement_Opcode(stmt, opcode),
  Variable_Value(var0, val0),
  Variable_Value(var1, val1),
  (OperationIs(opcode, val0, res) ; OperationIs(opcode, val1, res)).

// Does constant folding for addition
IsValue(res),
Variable_Value(resVar, res) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  ADD(stmt),
  Variable_Value(var0, val0),
  NumberToString(var0num, val0),
  Variable_Value(var1, val1),
  NumberToString(var1num, val1),
  NumberToString(var0num+var1num, res).

// DUP
LocalStackContents(stmt, 0, duplicated) :-
  BeforeLocalStackContents(stmt, n-1, duplicated),
  Statement_Opcode(stmt, opcode),
  DUPN(opcode, n).

LocalStackContents(stmt, m+1, other) :-
  BeforeLocalStackContents(stmt, m, other),
  Statement_Opcode(stmt, opcode),
  DUPN(opcode, n),
  IsStackIndexLessThan(m, n).

// Optimization: before local stack contents for swaps
// It's quite useful to optimize this case.
.decl BeforeSwapLocalStackContents(stmt: Statement, n: StackIndex, m: StackIndex, variable: Variable)

BeforeSwapLocalStackContents(stmt, n, m, variable) :-
  BeforeLocalStackContents(stmt, m, variable),
  Statement_Opcode(stmt, opcode),
  SWAPN(opcode, n).
   
// SWAP
LocalStackContents(stmt, n, variable0),
LocalStackContents(stmt, 0, variableN) :-
  BeforeSwapLocalStackContents(stmt, n, n, variableN),
  BeforeSwapLocalStackContents(stmt, n, 0, variable0).
  .plan 1:(2,1)

LocalStackContents(stmt, m, other) :-
  BeforeSwapLocalStackContents(stmt, n, m, other),
  IsStackIndexLessThan(m, n), m > 0.


/*
 ***********
 * CFG edges and reachable contexts
 ***********
 */

ReachableContext(calleeCtx, callee) :-
  BlockEdge(_, _, calleeCtx, callee).
  
ReachableContext(initCtx, FUNCTION_SELECTOR) :-
  InitialContext(initCtx).

.decl FallthroughStmt(stmt:Statement)

FallthroughStmt(stmt) :-
  BasicBlock_Tail(_, stmt),
  !JUMP(stmt),
  Statement_Opcode(stmt, opcode),
  !OpcodePossiblyHalts(opcode).   

.decl FallthroughEdge(caller: Block, fallthroughBlock: Block)

FallthroughEdge(caller, CAST_TO_SYMBOL(fallthrough)),
BlockEdge(callerCtx, caller, calleeCtx, CAST_TO_SYMBOL(fallthrough)) :-
  ReachableContext(callerCtx, caller),
  MergeContext(callerCtx, caller, calleeCtx),
  FallthroughStmt(stmt),
  Statement_Block(stmt, caller),
  Statement_Next(stmt, fallthrough),
  IsBasicBlockHead(fallthrough).
  .plan 1:(2,1,3,4,5,6)

BlockEdge(callerCtx, caller, calleeCtx, callee) :-
  BlockJumpValidTarget(callerCtx, caller, _, callee),
  MergeContext(callerCtx, caller, calleeCtx).
  .plan 1:(2,1)

/*
 ***********
 * Auxiliary relations: BeforeLocalStackContents
 ***********
 */
.decl NextStmtInBlock(stmt: Statement, nextStmt: Statement)

NextStmtInBlock(prevStmt, stmt) :-
  Statement_Next(prevStmt, stmt),
  Statement_Block(prevStmt, block),
  Statement_Block(stmt, block).

// General case
BeforeLocalStackContents(stmt, n, variable) :-
  LocalStackContents(prevStmt, n, variable),
  NextStmtInBlock(prevStmt, stmt).

// Special case for block head (contains only stackIndexes). Initialize all
// stack positions, from zero to max consumed (from the caller's stack) by
// the basic block. They are initialized to symbolic stackIndexes.
BeforeLocalStackContents(stmt, stackIndex, stackIndex) :-
  IsBasicBlockHead(stmt),
  Statement_Block(stmt, block),
  BlockPopDelta(block, delta),
  IsStackIndexLessThan(stackIndex, delta).

.decl Statement_Uses(stmt:Statement, var:Variable, n:StackIndex)
.decl Statement_Uses_Local(stmt:Statement, var:VariableOrStackIndex, n:StackIndex)


Statement_Uses_Local(stmt, varOrStackIndex, n) :-
   Statement_Opcode(stmt, opcode),
   !TACNOP(stmt),
   OpcodePopWords(opcode, m),
   IsStackIndexLessThan(n, m),
   BeforeLocalStackContents(stmt, n, varOrStackIndex).

// Case: variable originates locally
Statement_Uses(stmt, var, n) :-
   Statement_Uses_Local(stmt, var, n),
   CheckIsVariable(var).

// Case: variable originates elsewhere
Statement_Uses(stmt, var, n) :-
   Statement_Uses_Local(stmt, stackIndex, n),
   CheckIsStackIndex(stackIndex),
   Statement_Block(stmt, block),
   BlockInputContents(_, block, stackIndex, var).

/*
 ***********
 * Auxiliary relations: block/statement pop deltas and total stack effects
 ***********
 */

StatementStackDelta(stmt, delta) :-
  IsBasicBlockHead(stmt),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, delta).

StatementStackDelta(stmt, prevdelta + newdelta) :-
  StatementStackDelta(prevstmt, prevdelta),
  !BasicBlock_Tail(_, prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, newdelta).

// Need to keep a running maximum of elements consumed from the stack
// as it was at the beginning of the basic block.
StatementPopDelta(stmt, delta) :-
  IsBasicBlockHead(stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, delta).

// This intermediate relation was introduced for optimization purposes
.decl StatementPopDeltaNew(stmt: Statement, prevPopDelta: StackIndex, newPopDelta: StackIndex)

StatementPopDeltaNew(stmt, prevPopDelta, popDelta - prevStackDelta) :-
  StatementPopDelta(prevstmt, prevPopDelta),
  !BasicBlock_Tail(_, prevstmt),
  StatementStackDelta(prevstmt, prevStackDelta),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, popDelta).

StatementPopDelta(stmt, newPopDelta) :-
  StatementPopDeltaNew(stmt, prevPopDelta, newPopDelta),
  newPopDelta > prevPopDelta.

StatementPopDelta(stmt, prevPopDelta) :-
  StatementPopDeltaNew(stmt, prevPopDelta, newPopDelta),
  newPopDelta <= prevPopDelta.

BlockStackDelta(block, delta) :-
  BasicBlock_Tail(block, stmt),
  StatementStackDelta(stmt, delta).

BlockPopDelta(block, delta) :-
  BasicBlock_Tail(block, stmt),
  StatementPopDelta(stmt, delta).

.decl PublicFunctionJump(block:Block, funHex:symbol)

.decl PublicFunctionStart(block:Block, funHex:symbol)

.output PublicFunctionJump
PublicFunctionJump(block, sigHash):-
  ImmediateBlockJumpTarget(block, _),
  BasicBlock_Tail(block, jumpi),
  Statement_Opcode(jumpi, "JUMPI"),
  BeforeLocalStackContents(jumpi, 1, condVar),
  CheckIsVariable(condVar),
  Statement_Defines(eq, condVar),
  Statement_Opcode(eq, "EQ"),
  BeforeLocalStackContents(eq, 0, sigHashVar),
  CheckIsVariable(sigHashVar),
  Statement_Defines(push, sigHashVar),
    (PUSH4(push, sigHash) ; PUSH3(push, sigHash)).

.output PublicFunctionStart
PublicFunctionStart(CAST_TO_SYMBOL(targetValue), sigHash):-
  PublicFunctionJump(block, sigHash),
  ImmediateBlockJumpTarget(block, var),
  Statement_Defines(push, var),
  PushValue(push, targetValue),
  JUMPDEST(CAST_TO_SYMBOL(targetValue)).