// The core of the decompiler logic. Most complex reasoning for value
// flow and detecting CFG edges (much like the Vandal decompiler) is here.

#define MAX_STACK_HEIGHT 50
#define CAST_TO_SYMBOL(b) cat("", (b))
#define CheckIsVariable(v) ((v) < 0)
#define CheckIsStackIndex(v) ((v) >= 0, (v) < MAX_STACK_HEIGHT)
#define FUNCTION_SELECTOR "0x0"

#include "../clientlib/util.dl"
#include "local.dl"
#include "N-Call-Context.dl"
#include "decompiler_input_opcodes.dl"
#include "functions.dl"
#include "decompiler_output.dl"
#include "statement_insertor.dl"

#ifndef NO_ANALYTICS
#include "decompiler_analytics.dl"
#endif

.type Block 
.type Value
.number_type Variable
.number_type StackIndex
.type VariableOrStackIndex = Variable | StackIndex
.type Opcode
.type Statement 


.decl IsStackIndex(n:StackIndex)
        
IsStackIndex(0).
  
IsStackIndex(n+1) :-
  IsStackIndex(n),
  n+1 < MAX_STACK_HEIGHT.
  
// Convenience predicate. Folds together bounds checking on valid
// indices and less-than.
.decl IsStackIndexLessThan(n:StackIndex, maximum:StackIndex) inline
                                                               
IsStackIndexLessThan(n, maximum) :-
  IsStackIndex(maximum),
  IsStackIndex(n),
  n < maximum.

/*
 * Preprocessing of decompiler input, to yield convenient relations
 */

                                         
.comp StatementFactReader {                                         
  .decl PushValue(stmt:Statement, v:Value)
  .decl Statement_Opcode(statement: Statement, opcode: Opcode)
  .decl Statement_Next(statement: Statement, statementNext: Statement)

  .input PushValue(IO="file", filename="PushValue.facts")
  .input Statement_Opcode(IO="file", filename="Statement_Opcode.facts")
  .input Statement_Next(IO="file", filename="Statement_Next.facts")
  
}

.init factReader = StatementFactReader


/*
 ***********
 * Transformation-aided decompilation
 ***********
 */

.init preTrans = PreTransLocalAnalysis
COPY_CODE(preTrans, factReader)

INITIALIZE_STATEMENT_INSERTOR_FROM(insertor, preTrans, postTrans)

insertor.removeOp(jumpStmt),
insertor.removeOp(pushStmt),
insertor.insertOps(pushStmt,
  LIST(
    STMT(PUSH4, MAKE_LABEL_REFERENCE(jumpDestStmt)),
    STMT(JUMPI, "")
  )
),
insertor.insertOps(CAST_TO_SYMBOL(jumpDestStmt),
  LIST(
    STMT(JUMPDEST, MAKE_LABEL_REFERENCE(jumpDestStmt)),
    STMT(PUSH4, CAST_TO_SYMBOL(jumpDestStmt)),
    STMT(JUMP, cat("PublicFunctionJump:", hash))
  )
) :-
   preTrans.PublicFunctionJump(block, hash),
   preTrans.PublicFunction(start, hash),
   preTrans.Statement_Block(jumpDestStmt, start),
   preTrans.JUMPDEST(jumpDestStmt),
   preTrans.PushValue(pushStmt, CAST_TO_SYMBOL(jumpDestStmt)),
   preTrans.Statement_Block(pushStmt, block),
   preTrans.BasicBlock_Tail(block, jumpStmt).



/*
// Fallback function TODO
insertor.insertOps(fallthrough,
  LIST(
    STMT(PUSH4, CAST_TO_SYMBOL(fallthrough)),
    STMT(JUMP, "")
  )
) :- FallbackStart(fallthrough), JUMPDEST(fallthrough).


insertor.insertOps(fallthrough,
  LIST(
    STMT(PUSH4, MAKE_LABEL_REFERENCE("fallback")),
    STMT(JUMP, ""),
    STMT(JUMPDEST, MAKE_LABEL_REFERENCE("fallback"))
  )
) :- FallbackStart(fallthrough), !JUMPDEST(fallthrough).
*/

.init postTrans = PostTransLocalAnalysis

postTrans.PublicFunctionJump(block, substr(meta, 19, 30)) :-
   insertor.MetaData(stmt, meta),
   STARTSWITH(meta, "PublicFunctionJump:"),
   postTrans.Statement_Block(stmt, block).

postTrans.PublicFunction(b, h) :- preTrans.PublicFunction(b, h).

/*
 ***********
 * Key dataflow definitions
 ***********
 */
 

// Stack contents at input and output of a block, given its calling context.
.decl BlockOutputContents(context:Context, block:Block, index:StackIndex, var:Variable)
.decl BlockInputContents(context:Context, block:Block, index:StackIndex, var:Variable)

// Var holding the (target block) address a block jumps to, under context.
.decl BlockJumpTarget(context:Context, block:Block, var:Variable)

.decl BlockEdge(callerCtx:Context, caller:Block, calleeCtx:Context, callee:Block)
.decl ReachableContext(ctx:Context, block:Block)


/*
 ***********
 * Define block's behavior based on constituents
 ***********
 */

BlockInputContents(calleeCtx, callee, index, variable) :-
  BlockOutputContents(callerCtx, caller, index, variable),
  BlockEdge(callerCtx, caller, calleeCtx, callee).
  .plan 1:(2,1)
      
// Copy the stack variables untouched by the callee basic block
BlockOutputContents(calleeCtx, callee, index+delta, variable) :-
  BlockInputContents(calleeCtx, callee, index, variable),
  index >= calleePopLen,
  index+delta <= MAX_STACK_HEIGHT,
  postTrans.BlockPopDelta(callee, calleePopLen),
  postTrans.BlockStackDelta(callee, delta).

// Handle the proper variables pushed by this basic block
BlockOutputContents(ctx, block, index, var) :-
  ReachableContext(ctx, block),
  postTrans.BasicBlock_Tail(block, stmt),
  postTrans.LocalStackContents(stmt, index, var),
  CheckIsVariable(var).

// Handle the stackIndexes pushed by this basic block
BlockOutputContents(ctx, block, index, realVariable) :-
  BlockInputContents(ctx, block, stackIndex, realVariable),
  postTrans.BasicBlock_Tail(block, stmt),
  postTrans.LocalStackContents(stmt, index, stackIndex),
  CheckIsStackIndex(stackIndex).


BlockJumpTarget(ctx, block, var) :-
  ReachableContext(ctx, block),
  postTrans.ImmediateBlockJumpTarget(block, var).

BlockJumpTarget(ctx, block, realVariable) :-
  BlockInputContents(ctx, block, stackIndex, realVariable),
  CheckIsStackIndex(stackIndex),
  postTrans.BasicBlock_Tail(block, stmt),
  postTrans.IsJump(stmt),
  postTrans.BeforeLocalStackContents(stmt, 0, stackIndex).


// Under ctx, the block's tail will jump to the value of "variable", which
// is equal to the label of "target" block.
.decl BlockJumpValidTarget(ctx:Context, block:Block, variable: Variable, target:Block)

BlockJumpValidTarget(ctx, block, targetVar, CAST_TO_SYMBOL(targetValue)) :-
  BlockJumpTarget(ctx, block, targetVar),
  postTrans.Variable_Value(targetVar, targetValue),
  postTrans.JUMPDEST(CAST_TO_SYMBOL(targetValue)).


/*
 ***********
 * CFG edges and reachable contexts
 ***********
 */

ReachableContext(calleeCtx, callee) :-
  BlockEdge(_, _, calleeCtx, callee).
  
ReachableContext(initCtx, FUNCTION_SELECTOR) :-
  InitialContext(initCtx).

.decl FallthroughEdge(caller: Block, fallthroughBlock: Block)

FallthroughEdge(caller, CAST_TO_SYMBOL(fallthrough)),
BlockEdge(callerCtx, caller, calleeCtx, CAST_TO_SYMBOL(fallthrough)) :-
  ReachableContext(callerCtx, caller),
  MergeContext(callerCtx, caller, calleeCtx),
  postTrans.FallthroughStmt(stmt),
  postTrans.Statement_Block(stmt, caller),
  postTrans.Statement_Next(stmt, fallthrough),
  postTrans.IsBasicBlockHead(fallthrough).
  .plan 1:(2,1,3,4,5,6)

BlockEdge(callerCtx, caller, calleeCtx, callee) :-
  BlockJumpValidTarget(callerCtx, caller, _, callee),
  MergeContext(callerCtx, caller, calleeCtx).
  .plan 1:(2,1)


.decl Statement_Uses(stmt:Statement, var:Variable, n:StackIndex)

// Case: variable originates locally
Statement_Uses(stmt, var, n) :-
   postTrans.Statement_Uses_Local(stmt, var, n),
   CheckIsVariable(var).

// Case: variable originates elsewhere
Statement_Uses(stmt, var, n) :-
   postTrans.Statement_Uses_Local(stmt, stackIndex, n),
   CheckIsStackIndex(stackIndex),
   postTrans.Statement_Block(stmt, block),
   BlockInputContents(_, block, stackIndex, var).


// Masks with all 1s
.decl Mask_Length(mask: Value, bytes: number)
.decl PreMask_Length(mask: symbol, bytes: number)

Mask_Length(cat("0x", mask), bytes) :-
   PreMask_Length(mask, bytes).

PreMask_Length("1", 1).
PreMask_Length("3", 1).
PreMask_Length("7", 1).
PreMask_Length("f", 1).
PreMask_Length("1f", 1).
PreMask_Length("3f", 1).
PreMask_Length("7f", 1).
PreMask_Length("ff", 1).

PreMask_Length(cat("ff", mask), bytes+1) :-
  PreMask_Length(mask, bytes),
  bytes < 32.
