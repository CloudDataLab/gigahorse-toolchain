#define MAX_FUNCTION_ARGS (MAX_STACK_HEIGHT/4)
#define FRESH_VARIABLE(var, stmt, stackIndex) (IRStatementNum((stmt), _stmtNum), var=-0xFFFF+_stmtNum*MAX_STACK_HEIGHT+(stackIndex))

/*****
 * Function discovery logic
 *****/

/******
  * First, heuristics for discovering public functions
******/
// Special entry point to public function found heuristically
.decl PublicFunction(basicBlock: Block, sigHash: Value)
// Code inserted by compiler to dispatch to the correct public function
.decl PublicFunctionDispatcher(basicBlock: Block, sigHash: Value)
// (Possibly) Code inserted by compiler to compare function signature
.decl BlockComparesSig(block: Block, sigHash: Value)

// Compares label from stack to a constant: common public function dispatch
// pattern
BlockComparesSig(block, sigHash) :-
  Statement_Block(pushStmt, block),
  PUSH4(pushStmt, sigHash),
  Statement_Defines(pushStmt, sigHashVar),
  Statement_Block(eqStmt, block),
  EQ(eqStmt),
  Statement_Uses(eqStmt, sigHashVar, _),
  Statement_Block(jumpiStmt, block),
  JUMPI(jumpiStmt),
  Statement_Defines(eqStmt, pred),
  Statement_Uses(jumpiStmt, pred, 1).

// Initial case, uses CALLDATALOAD
PublicFunctionDispatcher(block, sigHash) :-
  Statement_Block(stmt, block),
  CALLDATALOAD(stmt),
  BlockComparesSig(block, sigHash).

// General case
PublicFunctionDispatcher(block, sigHash) :-
  BlockComparesSig(block, sigHash),
  BlockEdge(_, prev, _, block),
  PublicFunctionDispatcher(prev, _).

PublicFunction(stmtBlock, sigHash) :-
  PublicFunctionDispatcher(block, sigHash),
  Statement_Block(jumpiStmt, block),
  JUMPI(jumpiStmt),
  BeforeLocalStackContents(jumpiStmt, _, labelvar),
  Variable_Value(labelvar, label),
  IsBasicBlockHead(stmt),
  CastStatementToBlock(stmt, stmtBlock),
  ord(label) = ord(stmt).


/******
         Generic basic block Reachable-from implementation
******/

.decl ReachableFrom(block:Block, from:Block)

ReachableFrom(block, block) :- Statement_Block(_, block).

ReachableFrom(blockNext, blockPrev) :-
  ReachableFrom(block, blockPrev),
  BlockEdge(_, block, _, blockNext). 


/******
         Heuristics for detecting call-return patterns
******/

.decl PossibleReturnAddress(caller:Block, ret:Block, target:Block)

// Possibly a return:
// a) basic block jumps to a valid "non-locally-derived" address
// b) address originates at a caller that can reach the
//    returning basic block.
PossibleReturnAddress(callerBlock, retBlock, retTarget) :-
   BlockJumpValidTarget(_, retBlock, targetVariable, retTarget),
   !ImmediateBlockJumpTarget(_, retBlock, targetVariable),
   BasicBlock_Tail(callerBlock, callerStmt),
   IsJump(callerStmt),
   Statement_Defines(otherCallerStatement, targetVariable),
   Statement_Block(otherCallerStatement, callerBlock).

// c) each callerblock has different return address
.decl ConflictingReturnAddress(caller:Block, ret:Block, target:Block)

ConflictingReturnAddress(callerBlock, retBlock, retTarget) :-
   PossibleReturnAddress(callerBlock, retBlock, retTarget),
   PossibleReturnAddress(callerBlock2, _, retTarget),
   callerBlock != callerBlock2.

.decl InlineProcedureEntry(entry: Block)
.output InlineProcedureEntry

InlineProcedureEntry(entry) :-
   InlineableBlock(entry),
   ConflictingReturnAddress(_, _, entry).


// block with no out edges
.decl TerminalBlock(b: Block)
TerminalBlock(b) :- Statement_Block(_, b), !BlockEdge(_, b, _, _).

.decl TerminalBlockReachableThrough(from: Block, through: Block, terminal: Block)
TerminalBlockReachableThrough(b, b, b) :- TerminalBlock(b).

TerminalBlockReachableThrough(from, through, terminal),
TerminalBlockReachableThrough(from, other, terminal),
TerminalBlockReachableThrough(from, from, terminal) :-
   TerminalBlockReachableThrough(other, through, terminal),
   BlockEdge(_, from, _, other).

.decl CountTerminalBlockReachableThrough(from: Block, terminal: Block, n: number)
CountTerminalBlockReachableThrough(from, terminal, n) :-
   TerminalBlockReachableThrough(from, _, terminal),
   n = count : TerminalBlockReachableThrough(from, _, terminal).

.decl TotalCountOfBlocksUntilTerminal(from: Block, n: number)
TotalCountOfBlocksUntilTerminal(from, n) :-
   CountTerminalBlockReachableThrough(from, terminal, _),
   n = sum k : CountTerminalBlockReachableThrough(from, _, k).

.output InlineableBlock
.decl InlineableBlock(entry: Block)
InlineableBlock(block) :-
   Statement_Block(_, block),
   TotalCountOfBlocksUntilTerminal(block, n),
   n <= 8.

.decl PossibleFunctionCall(caller:Block, func:Block, retBlock:Block, retTarget:Block)

PossibleFunctionCall(caller, func, retBlock, retTarget) :-
  PossibleReturnAddress(caller, retBlock, retTarget),
  (!ConflictingReturnAddress(caller, retBlock, retTarget) ;
   InlineableBlock(retTarget)),
  BlockJumpValidTarget(_, caller, _, func),
  !InlineableBlock(func).

.decl PossiblyInFunction(block:Block, func:Block)

// Which basic blocks belong to which function
PossiblyInFunction(func, func) :-
  PossibleFunctionCall(_, func, _, _).

// In this case we're moving onto another function
PossiblyInFunction(next, func) :-
  PossiblyInFunction(block, func),
  BlockEdge(_, block, _, next),
  !PossibleFunctionCall(block, _, _, _).

// In this case we're return from a function we've just called
PossiblyInFunction(retTarget, func) :-
  PossiblyInFunction(block, func),
  PossibleFunctionCall(block, _, _, retTarget).

// What is a function?
// 1) A function has to have a single entry point
// 2) has to be called multiple times
// 3) If code is inlined it's something else

.decl FunctionCalledMultipleTimes(func: Block)

FunctionCalledMultipleTimes(func) :-
   PossibleFunctionCall(caller, func, _, _),
   PossibleFunctionCall(caller2, func, _, _),
   caller != caller2.


// caller calls func and func returns to retTarget
.decl FunctionCallReturn(caller:Block, func:Block, retTarget:Block)
.decl Function_Return(func:Block, retBlock:Block)
.decl Function_Return_Edge(block: Block, next: Block)

Function_Return_Edge(retBlock, retTarget),
Function_Return(func, retBlock),
FunctionCallReturn(caller, func, retTarget) :-
  PossibleFunctionCall(caller, func, retBlock, retTarget),
  FunctionCalledMultipleTimes(func),
  !InlineableBlock(func).

// Further function decomposition.
// Detects function boundaries, calls and returns iteratively.  Main
// heuristic: if a block is reachable by two others that have to be in
// different functions, then that block is also in an independent
// function.

// Used components to force stratification.
.comp FunctionDetection {
  // An Entry to a function (private or public)
  .decl FunctionEntry(block: Block)
  // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionEntry(block: Block)

  // Basic block belongs to function
  .decl InFunction(block: Block, function: Block)
  // Basic block performs a function call 
  .decl FunctionCall(block: Block, func: Block)
   // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionCall(block: Block, func: Block)

  InFunction(block, block) :-
    PrevFunctionEntry(block).

  InFunction(next, func) :-
    InFunction(block, func),
    BlockEdge(_, block, _, next),
    !PrevFunctionCall(block, next),
    !Function_Return(_, block).

 InFunction(next, func) :-
   InFunction(block, func),
   FunctionCallReturn(block, _, next).

  // Heuristic for finding function calls
  // Execution flows to a basic block that is
  // part of more than one function, TODO
  FunctionCall(prev, block),
  FunctionEntry(block) :-
    InFunction(block, func1),
    InFunction(block, func2),
    func1 != func2,
    BlockEdge(_, prev, _, block),
    !InlineableBlock(block),
    !Function_Return(_, prev),
    !(InFunction(prev, func1), InFunction(prev, func2)).

  .decl InlineProcedureEntry(block: Block)

  InlineProcedureEntry(block) :-
    InFunction(block, func1),
    InFunction(block, func2),
    func1 != func2,
    BlockEdge(_, prev, _, block),
    InlineableBlock(block),
    !Function_Return(_, prev),
    !(InFunction(prev, func1), InFunction(prev, func2)).

  FunctionCall(prev, block) :-
    PrevFunctionEntry(block),
    BlockEdge(_, prev, _, block),
    !Function_Return(_, prev).

  FunctionCall(prev, func1) :- PrevFunctionCall(prev, func1).
  FunctionEntry(block) :- PrevFunctionEntry(block).
}

// Initialize and iterate the algorithm
.init detector0 = FunctionDetection
detector0.PrevFunctionEntry(block) :-
   PublicFunction(block, _).

detector0.PrevFunctionEntry(FUNCTION_SELECTOR).
   
detector0.PrevFunctionEntry(block) :-
  FunctionCallReturn(_, block, _).

detector0.PrevFunctionCall(prev, func) :-
  PublicFunction(func, sigHash),
  PublicFunctionDispatcher(prev, sigHash).

detector0.PrevFunctionCall(prev, func) :-
  FunctionCallReturn(prev, func, _).

.init detector1 = FunctionDetection
detector1.PrevFunctionEntry(block) :- detector0.FunctionEntry(block).
detector1.PrevFunctionCall(block, func) :- detector0.FunctionCall(block, func).

.init detector2 = FunctionDetection
detector2.PrevFunctionEntry(block) :- detector1.FunctionEntry(block).
detector2.PrevFunctionCall(block, func) :- detector1.FunctionCall(block, func).

.init detector3 = FunctionDetection
detector3.PrevFunctionEntry(block) :- detector2.FunctionEntry(block).
detector3.PrevFunctionCall(block, func) :- detector2.FunctionCall(block, func).

/***********
   Collecting all function decomposition results
***********/

// block ends with a call to func
.decl FunctionCall(block:Block, func:Block)

// Case 1: private call return
FunctionCall(block, func) :- FunctionCallReturn(block, func, _).

// Case 2: dispatch public functions
FunctionCall(block, func) :-
  PublicFunction(func, sigHash),
  PublicFunctionDispatcher(block, sigHash).

// Case 3: further decomposition using components
FunctionCall(block, func) :-
  detector0.FunctionCall(block, func) ;
  detector1.FunctionCall(block, func) ;
  detector2.FunctionCall(block, func) ;
  detector3.FunctionCall(block, func).

.decl Function(func:Block)

// Case 1: Smart contract entry
Function(FUNCTION_SELECTOR).

// Remaining cases handled by inputs/outputs of componenets
Function(func) :-
  detector0.PrevFunctionEntry(func) ;
  detector0.FunctionEntry(func) ;
  detector1.FunctionEntry(func) ;
  detector2.FunctionEntry(func) ;
  detector3.FunctionEntry(func).


InlineProcedureEntry(block) :-
  detector3.InlineProcedureEntry(block).

/***********
 * Identify actual function calls and returns
 ***********/
.decl FunctionCallStmt(stmt: Statement)

FunctionCallStmt(stmt) :-
   FunctionCall(block, _),
   IsJump(stmt),
   BasicBlock_Tail(block, stmt).

.decl FunctionReturnStmt(stmt: Statement)

FunctionReturnStmt(stmt) :-
   Function_Return(_, block),
   IsJump(stmt),
   BasicBlock_Tail(block, stmt).

// Create fresh call statements here if jump doesn't exist
// TODO (if needed)
/*
.decl IRBasicBlock_CALL(block: IRBlock, stmt: IRStatement)

IRBasicBlock_CALL(block, stmt),
IRFunctionCallStmt(stmt) :-
   FunctionCall(block, _),
   IRIsJump(stmt),
   IRBasicBlock_Tail(block, stmt).

IRStatementNum(newStmt, num+1),
IRBasicBlock_CALL(block, newStmt),
Statement_IRStatement(...),
FunctionCallStmt(newStmt) :-
   newStmt = cat(irstmt,"_call"),                
   IRFunctionCall(block, _),
   !IRIsJump(irstmt),
   IRBasicBlock_Tail(block, irstmt),
   Statement_IRStatement(stmt, irstmt),
   _StatementNum(stmt, num).
*/    


/***********
 * Introduce new IR
 ***********/
#define FRESH_IRBLOCK(b, f) cat((b), (f))
#define BLOCK_TO_IRBLOCK(b) substr(cat(" ", (b)), 1, 10)
#define FRESH_IRSTATEMENT(s, f) cat((s), (f))
#define STATEMENT_TO_IRSTATEMENT(s) substr(cat(" ", (s)), 1, 10)
 
.type IRBlock
// exploit type checking in new IR
#define IRFunction Block
.type IRStatement

.decl Block_IRBlock(block: Block, irblock: IRBlock)
.decl InFunction(block: IRBlock, func: IRFunction)
.decl IRFunctionEntry(from: IRBlock)

IRFunctionEntry(irblock),
Block_IRBlock(funcentry, irblock),
InFunction(irblock, funcentry) :-
  irblock = BLOCK_TO_IRBLOCK(funcentry),
  Function(funcentry).

Block_IRBlock(next, irnext),
InFunction(irnext, func) :-
  BlockEdge(_, block, _, next),
  InlineableBlock(next),
  Block_IRBlock(block, irblock),
  InFunction(irblock, func),
  irnext = FRESH_IRBLOCK(next, func),
  !Function(next),
  !Function_Return_Edge(block, next).

Block_IRBlock(next, irnext),
InFunction(irnext, func) :-
  BlockEdge(_, block, _, func_call),
  FunctionCallReturn(block, func_call, next),
  Block_IRBlock(block, irblock),
  InFunction(irblock, func),
  InlineableBlock(next),
  irnext = FRESH_IRBLOCK(next, func).

Block_IRBlock(next, irnext),
InFunction(irnext, func) :-
  BlockEdge(_, block, _, next),
  !InlineableBlock(next),
  !Function(next),
  !Function_Return_Edge(block, next),
  Block_IRBlock(block, irblock),
  InFunction(irblock, func),
  irnext = BLOCK_TO_IRBLOCK(next).

Block_IRBlock(next, irnext),
InFunction(irnext, func) :-
  BlockEdge(_, block, _, func_call),
  FunctionCallReturn(block, func_call, next),
  !InlineableBlock(next),
  Block_IRBlock(block, irblock),
  InFunction(irblock, func),
  irnext = BLOCK_TO_IRBLOCK(next).

.decl IRFunction_Return_Edge(block: IRBlock, next: IRBlock)
.decl IRFunction_Return(fn: IRFunction, ret: IRBlock)
.decl IRFunctionCallReturn(caller: IRBlock, func: IRFunction, retcaller: IRBlock)

.output Function_Return

IRFunction_Return(func, retir),
IRFunctionCallReturn(callerir, func, callerretir),
IRFunction_Return_Edge(retir, callerretir) :-
   FunctionCallReturn(caller, func, callerret),
   Function_Return(func, ret),
   Block_IRBlock(ret, retir),
   Block_IRBlock(caller, callerir),
   Block_IRBlock(callerret, callerretir),
   InFunction(callerir, prevfunc),
   InFunction(callerretir, prevfunc).

.decl IRFunctionCall(from: IRBlock, func: IRFunction)

IRFunctionCall(fromir, func) :-
   FunctionCall(from, func),
   Block_IRBlock(from, fromir).

// Intra-function edges (i.e., real CFG edges)
.decl LocalBlockEdge(block: IRBlock, next: IRBlock)

LocalBlockEdge(block, next) :-
  IRBlockEdge(block, next),
  InFunction(block, func),
  InFunction(next, func),
  !IRFunctionEntry(next),
  !IRFunction_Return_Edge(block, next).

LocalBlockEdge(block, next) :-
  IRFunctionCallReturn(block, _, next).

.decl IRFallthroughEdge(from: IRBlock, to: IRBlock)

IRFallthroughEdge(irfrom, irto) :-
  FallthroughEdge(from, to),
  Block_IRBlock(from, irfrom),
  Block_IRBlock(to, irto),
  InFunction(irfrom, func),
  InFunction(irto, func).

.decl IRBlockEdge(from: IRBlock, to: IRBlock)

IRBlockEdge(irfrom, irto) :-
   BlockEdge(_, from, _, to),
   Block_IRBlock(from, irfrom),
   Block_IRBlock(to, irto).

.decl Statement_IRStatement(stmt: Statement, irstmt: IRStatement)
.decl IRStatement_Block(stmt: IRStatement, to: IRBlock)

.decl IRStatement_VarString(irstmt: IRStatement, func: symbol)
.decl IRBlock_VarString(irblock: IRBlock, str: symbol)


IRStatement_VarString(irstmt, func),
IRBlock_VarString(irblock, func),
IRStatement_Block(irstmt, irblock),
Statement_IRStatement(stmt, irstmt) :-
   InlineableBlock(block),
   Statement_Block(stmt, block),
   Block_IRBlock(block, irblock),
   InFunction(irblock, func),
   irstmt = FRESH_IRSTATEMENT(stmt, func).

IRStatement_Block(irstmt, irblock),
Statement_IRStatement(stmt, irstmt) :-
   Statement_Block(stmt, block),
   !InlineableBlock(block),
   Block_IRBlock(block, irblock),
   irstmt = STATEMENT_TO_IRSTATEMENT(stmt).

.decl IRStatementNum(stmt: IRStatement, num: number)

IRStatementNum(irstmt, num) :-
   _StatementNum(stmt, num),
   Statement_IRStatement(stmt, irstmt).

.decl IRTACNOP(stmt: IRStatement)

IRTACNOP(irstmt) :-
  TACNOP(stmt),
  Statement_IRStatement(stmt, irstmt).

.decl IRStatement_Opcode(stmt: IRStatement, op: Opcode)

IRStatement_Opcode(irstmt, op) :-
   Statement_Opcode(stmt, op),
   Statement_IRStatement(stmt, irstmt),
   !FunctionCallStmt(stmt),
   !FunctionReturnStmt(stmt).

IRStatement_Opcode(irstmt, "CALLPRIVATEI") :-
   Statement_IRStatement(stmt, irstmt),
   JUMPI(stmt),
   FunctionCallStmt(stmt).

IRStatement_Opcode(irstmt, "CALLPRIVATE") :-
   Statement_IRStatement(stmt, irstmt),
   !JUMPI(stmt),
   FunctionCallStmt(stmt).

IRStatement_Opcode(irstmt, "RETURNPRIVATEI") :-
   Statement_IRStatement(stmt, irstmt),
   JUMPI(stmt),
   FunctionReturnStmt(stmt).

IRStatement_Opcode(irstmt, "RETURNPRIVATE") :-
   Statement_IRStatement(stmt, irstmt),
   JUMP(stmt),
   FunctionReturnStmt(stmt).


.decl IRIsJump(stmt: IRStatement)

IRIsJump(irstmt) :-
   IsJump(stmt),
   Statement_IRStatement(stmt, irstmt).
 
.decl IRBasicBlock_Tail(block: IRBlock, tail: IRStatement)

IRBasicBlock_Tail(irblock, irtail) :-
   BasicBlock_Tail(block, tail),
   Block_IRBlock(block, irblock),
   Statement_IRStatement(tail, irtail),
   IRStatement_Block(irtail, irblock).

.decl IRBlockPopDelta(from: IRBlock, n: StackIndex)
.decl IRBlockStackDelta(from: IRBlock, stackDelta: StackIndex)

IRBlockPopDelta(irblock, n) :-
   BlockPopDelta(block, n),
   Block_IRBlock(block, irblock).

IRBlockStackDelta(irblock, stackDelta) :-
   BlockStackDelta(block, stackDelta),
   Block_IRBlock(block, irblock).

.decl IRStatement_Uses_Local(stmt: IRStatement, varOrStackIndex: VariableOrStackIndex, n: StackIndex)

IRStatement_Uses_Local(irstmt, varOrStackIndex, n) :-
  Statement_Uses_Local(stmt, varOrStackIndex, n),
  Statement_IRStatement(stmt, irstmt).

.decl IRBeforeLocalStackContents(stmt: IRStatement, n:StackIndex, varOrStackIndex:VariableOrStackIndex)

IRBeforeLocalStackContents(irstmt, n, varOrStackIndex) :-
  BeforeLocalStackContents(stmt, n, varOrStackIndex),
  Statement_IRStatement(stmt, irstmt).


.decl IRLocalStackContents(stmt: IRStatement, n:StackIndex, varOrStackIndex:VariableOrStackIndex)

IRLocalStackContents(irstmt, n, varOrStackIndex) :-
  LocalStackContents(stmt, n, varOrStackIndex),
  Statement_IRStatement(stmt, irstmt).

.decl IRThrowJump(irstmt: IRStatement)

IRThrowJump(irstmt) :-
   ThrowJump(stmt),
  Statement_IRStatement(stmt, irstmt).



/***********
 * Discovery of arguments accepted by a function   
 ***********/

// New Instructions
// CALLPRIVATE(stmt, function)
// CALLPRIVATEI(stmt, cond, function)
// RETURNPRIVATE(stmt)
// RETURNPRIVATEI(stmt, cond)

.decl NumberOfFunctionArguments(func: IRFunction, ret: IRBlock, num: StackIndex)
.decl NumberOfFunctionReturnArguments(func: IRFunction, num: StackIndex)

.decl EnhancedLocalBlockEdge(from: IRBlock, to: IRBlock)

EnhancedLocalBlockEdge(from, to) :- LocalBlockEdge(from, to).

EnhancedLocalBlockEdge(from, "invalid") :- InFunction(from, _), !LocalBlockEdge(from, _).

EnhancedLocalBlockEdge(from, "invalid") :- IRFunction_Return(_, from), InFunction(from, _).

.decl EdgePopDelta(from: IRBlock, to: IRBlock, delta: StackIndex)

EdgePopDelta(from, to, delta) :-
   EnhancedLocalBlockEdge(from, to),
   IRBlockEdge(from, to),
   IRBlockPopDelta(from, delta).

EdgePopDelta(from, to, delta) :-
   EnhancedLocalBlockEdge(from, to),
   !IRFunctionCall(from, _),
   IRBlockPopDelta(from, delta).

EdgePopDelta(from, to, newPopDelta) :-
   EnhancedLocalBlockEdge(from, to),
   !IRBlockEdge(from, to),
   IRFunctionCall(from, func),
   NumberOfFunctionArguments(func, _, n_args),
   IRBlockPopDelta(from, popDelta),
   IRBlockStackDelta(from, stackDelta),
   newPopDelta = n_args-stackDelta,
   newPopDelta < MAX_STACK_HEIGHT,
   newPopDelta >= popDelta.

EdgePopDelta(from, to, popDelta) :-
   EnhancedLocalBlockEdge(from, to),
   !IRBlockEdge(from, to),
   IRFunctionCall(from, func),
   NumberOfFunctionArguments(func, _, n_args),
   IRBlockPopDelta(from, popDelta),
   IRBlockStackDelta(from, stackDelta),
   newPopDelta = n_args-stackDelta,
   newPopDelta < popDelta.

.decl EdgeStackDelta(from: IRBlock, to: IRBlock, delta: StackIndex)

EdgeStackDelta(from, to, newStackDelta) :-
   CompositeNumberOfFunctionAndReturnArguments(func, n_args, n_ret),
   EnhancedLocalBlockEdge(from, to),
   !IRBlockEdge(from, to),
   IRFunctionCall(from, func),
   IRBlockStackDelta(from, stackDelta),
   newStackDelta = stackDelta-n_args+n_ret,
   newStackDelta < MAX_STACK_HEIGHT,
   newStackDelta > -MAX_STACK_HEIGHT.

EdgeStackDelta(from, to, stackDelta) :-
   EnhancedLocalBlockEdge(from, to),
   IRBlockEdge(from, to),
   IRBlockStackDelta(from, stackDelta).

EdgeStackDelta(from, to, stackDelta) :-
   EnhancedLocalBlockEdge(from, to),
   !IRFunctionCall(from, _),
   IRBlockStackDelta(from, stackDelta).

.decl FunctionEdgePopDelta(from: IRBlock, to: IRBlock, delta: StackIndex)

FunctionEdgePopDelta(from, to, delta) :-
   IRFunctionEntry(from),
   EdgePopDelta(from, to, delta).


.decl OptEdgePopDeltas(from: IRBlock, to: IRBlock, prevPopDelta: StackIndex, prevStackDelta: StackIndex, delta: StackIndex)

OptEdgePopDeltas(from, to, prevPopDelta, prevStackDelta, delta) :-
   FunctionEdgePopDelta(prev, from, prevPopDelta),
   FunctionEdgeStackDelta(prev, from, prevStackDelta),
   EdgePopDelta(from, to, delta),
   LocalBlockEdge(prev, from).
   .plan 1:(2,1,3,4), 2:(3,1,2,4)
   
FunctionEdgePopDelta(from, to, newPopDelta) :-
   OptEdgePopDeltas(from, to, prevPopDelta, prevStackDelta, delta),
   newPopDelta = delta - prevStackDelta,
   newPopDelta > prevPopDelta,
   newPopDelta < MAX_STACK_HEIGHT.

FunctionEdgePopDelta(from, to, delta) :-
   OptEdgePopDeltas(from, to, prevPopDelta, prevStackDelta, delta),
   newPopDelta = delta - prevStackDelta,
   newPopDelta <= prevPopDelta.

.decl FunctionEdgeStackDelta(from: IRBlock, to: IRBlock, delta: StackIndex)

FunctionEdgeStackDelta(from, to, delta) :-
   EdgeStackDelta(from, to, delta),
   IRFunctionEntry(from).

FunctionEdgeStackDelta(from, to, newStackDelta) :-
   FunctionEdgeStackDelta(prev, from, prevStackDelta),
   LocalBlockEdge(prev, from),
   EdgeStackDelta(from, to, delta),
   newStackDelta = delta + prevStackDelta,
   newStackDelta < MAX_STACK_HEIGHT,
   newStackDelta > -MAX_STACK_HEIGHT.
   .plan 1:(3, 2, 1)

.decl FunctionEdgePushDelta(from: IRBlock, to: IRBlock, delta: StackIndex)

FunctionEdgePushDelta(from, to, stackDelta + popDelta) :-
   FunctionEdgePopDelta(from, to, popDelta),
   FunctionEdgeStackDelta(from, to, stackDelta).
   .plan 1:(2, 1)

.decl Function_ArgumentTerminal(func: IRFunction, terminal: IRBlock)

// We mostly care about a function's signature when it returns
Function_ArgumentTerminal(func, ret),
NumberOfFunctionArguments(func, ret, delta) :-
   FunctionEdgePopDelta(ret, "invalid", delta),
   IRFunction_Return(func, ret).

NumberOfFunctionArguments(FUNCTION_SELECTOR, block, 0) :-
   Function_ArgumentTerminal(FUNCTION_SELECTOR, block).

// TODODODOD

Function_ArgumentTerminal(func, block),
NumberOfFunctionArguments(func, block, delta) :-
   FunctionEdgePopDelta(block, "invalid", delta),
   InFunction(block, func),
   !IRFunction_Return(func, _).


NumberOfFunctionReturnArguments(func, delta) :-
   FunctionEdgePushDelta(ret, "invalid", delta),
   IRFunction_Return(func, ret).

.output NumberOfFunctionArguments

// default
NumberOfFunctionReturnArguments(func, 0) :-
   Function(func),
   !IRFunction_Return(func, _).

.decl CandidateNumberOfFunctionArgumentsForReturn(func: IRFunction, ret: IRBlock, n: StackIndex)
CandidateNumberOfFunctionArgumentsForReturn(func, ret, n) :-
   Function_ArgumentTerminal(func, ret),
   n = min delta : NumberOfFunctionArguments(func, ret, delta).


.decl CandidateNumberOfFunctionArguments(func: IRFunction, n: StackIndex)
.output CandidateNumberOfFunctionArguments

CandidateNumberOfFunctionArguments(func, n) :-
   Function(func),
   n = max m : CandidateNumberOfFunctionArgumentsForReturn(func, _, m).

// This may improve precision, see further rant below
.decl CompositeNumberOfFunctionAndReturnArguments(func: IRFunction, n_in: StackIndex, n_out: StackIndex)

CompositeNumberOfFunctionAndReturnArguments(func, n_in, n_out) :-
   FunctionEdgePopDelta(ret, "invalid", n_in),
   FunctionEdgePushDelta(ret, "invalid", n_out),
   IRFunction_Return(func, ret).

.decl Variable_String(var:Variable, var_rep:symbol)

.decl Variable_Stmt_String(var:Variable, stmt: IRStatement, var_rep:symbol)

Variable_Stmt_String(var, stmt, cat(stmt_str, var_str)) :-
   IRStatement_VarString(stmt, stmt_str),
   Variable_String(var, var_str).

Variable_Stmt_String(var, stmt, var_str) :-
   !IRStatement_VarString(stmt, _),
   IRStatement_Block(stmt, _),
   Variable_String(var, var_str).

.decl Variable_Block_String(var:Variable, block: IRBlock, var_rep:symbol)

Variable_Block_String(var, block, cat(block_str, var_str)) :-
   IRBlock_VarString(block, block_str),
   Variable_String(var, var_str).

Variable_Block_String(var, block, var_str) :-
   !IRBlock_VarString(block, _),
   IRStatement_Block(_, block),
   Variable_String(var, var_str).

.decl FunctionArgument(func: IRFunction, n: StackIndex, var: Variable)
.decl FunctionCallReturnArgument(func: IRBlock, n: StackIndex, var: Variable)

.decl FunctionalStatement_Uses_Local(stmt: IRStatement, var:VariableOrStackIndex, n:StackIndex)

.decl FunctionalStatement_Uses(stmt:IRStatement, var:Variable, n:StackIndex)
.decl FunctionalStatement_Defines(callStmt:IRStatement, newVar:Variable, n: number)


Variable_String(var, var_rep) :-
   Statement_Defines(var_rep, var).

Variable_String(var, cat("arg",n_str)),
FunctionArgument(func, n, var) :-
  CandidateNumberOfFunctionArguments(func, n_args),
  IsStackIndexLessThan(n, n_args),
  FRESH_VARIABLE(var, BLOCK_TO_IRBLOCK(func), n), // TODO: use entry?
  NumberToString(n, n_str).

Variable_String(newVar, cat(callStmt, cat("_", n_str))),
FunctionalStatement_Defines(callStmt, newVar, n),
FunctionCallReturnArgument(caller, n, newVar) :-
  IRFunctionCall(caller, func),
  NumberOfFunctionReturnArguments(func, n_arg),
  IsStackIndexLessThan(n, n_arg),
  IRBasicBlock_Tail(caller, callStmt),
  FRESH_VARIABLE(newVar, callStmt, n),
  NumberToString(n, n_str).

// Renaming variables in functions
// Involves Propagating variables, but doesn't require re-computing the CFG
.decl FunctionalBlockInputContents(block:IRBlock, index:number, var:Variable)
.decl FunctionalBlockOutputContents(block:IRBlock, next: IRBlock, index:number, var:Variable)

FunctionalBlockInputContents(entry, n, var) :-
   IRFunctionEntry(entry),
   InFunction(entry, func),
   FunctionArgument(func, n, var).

FunctionalBlockInputContents(next, index, variable) :-
  FunctionalBlockOutputContents(_, next, index, variable).

// IMPORTANT: Although this code is probably correct, representing values
// per edge is wasteful. Confirmed.
// Is the per-edge representation equivalent to jump-site sensitivity?

// 1) Normal block to block flow, i.e. no unconditional function calls from block to block
FunctionalBlockOutputContents(block, next, index, variable) :-
  BeforeFunctionCallFunctionalBlockOutputContents(block, index, variable),
  EnhancedLocalBlockEdge(block, next),
  IRBlockEdge(block, next).

// 2) Same, but for return blocks
FunctionalBlockOutputContents(block, next, index, variable) :-
   BeforeFunctionCallFunctionalBlockOutputContents(block, index, variable),
   EnhancedLocalBlockEdge(block, next),
   !IRFunctionCall(block, _).

// 3) First block calls a function, take return args from function call

FunctionalBlockOutputContents(caller, next, n, newVar) :-
   FunctionCallReturnArgument(caller, n, newVar),
   // Note, we can ignore the exact identity of the called function,
   // As fresh variables will be the same, we only care about the number of
   // return arguments. With more sophisticated analysis, this could change.
   IRFunctionCallReturn(caller, _, next).

// 4) First block calls a function, take any remaining variables that have
//    not been passed as arguments, and shift
FunctionalBlockOutputContents(caller, next, newIndex, variable) :-
   BeforeFunctionCallFunctionalBlockOutputContents(caller, index, variable),
   IRFunctionCallReturn(caller, func, next),
   // Why do we need all this complexity? At first I modelled this by
   // considering the cross product of possible number of args, but
   // later created the notion of a composite function signature.
   // Should improve precision in some cases
   //CompositeNumberOfFunctionAndReturnArguments(func, n_in, n_out),
   NumberOfFunctionReturnArguments(func, n_out),
   CandidateNumberOfFunctionArguments(func, n_in),
   index >= n_in,
   newIndex = index+n_out-n_in,
   newIndex >= 0,
   newIndex < MAX_STACK_HEIGHT.

.decl BeforeFunctionCallFunctionalBlockOutputContents(caller: IRBlock, index: StackIndex, variable: Variable)

// Copy the stack variables untouched by the callee basic block
BeforeFunctionCallFunctionalBlockOutputContents(callee, index+delta, variable) :-
  FunctionalBlockInputContents(callee, index, variable),
  index >= calleePopLen,
  index+delta <= MAX_STACK_HEIGHT,
  IRBlockPopDelta(callee, calleePopLen),
  IRBlockStackDelta(callee, delta).

// Handle the proper variables pushed by this basic block
BeforeFunctionCallFunctionalBlockOutputContents(block, index, var) :-
  InFunction(block, _),
  IRBasicBlock_Tail(block, stmt),
  IRLocalStackContents(stmt, index, var),
  CheckIsVariable(var).

// Handle the stackIndexes pushed by this basic block
BeforeFunctionCallFunctionalBlockOutputContents(block, index, realVariable) :-
  FunctionalBlockInputContents(block, stackIndex, realVariable),
  IRBasicBlock_Tail(block, stmt),
  IRLocalStackContents(stmt, index, stackIndex),
  CheckIsStackIndex(stackIndex).


// TODO, check case for function call
FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
  IRFunctionCall(block, func),
  IRBasicBlock_Tail(block, stmt),
  IRStatement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, m),
  CandidateNumberOfFunctionArguments(func, n_in),
  IsStackIndexLessThan(n, m+n_in),
  IRBeforeLocalStackContents(stmt, n, varOrStackIndex).

// TODO, check case for function return
FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
  NumberOfFunctionReturnArguments(func, n_out),
  IRFunction_Return(func, retBlock),
  IRBasicBlock_Tail(retBlock, stmt),
  IRStatement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, m),
  IsStackIndexLessThan(n, m+n_out),
  IRBeforeLocalStackContents(stmt, n, varOrStackIndex).

FunctionalStatement_Uses_Local(irstmt, varOrStackIndex, n) :-
   Statement_Uses_Local(stmt, varOrStackIndex, n),
   Statement_IRStatement(stmt, irstmt).

FunctionalStatement_Uses(irstmt, var, n) :-
   Statement_Uses_Local(stmt, var, n),
   CheckIsVariable(var),
   Statement_IRStatement(stmt, irstmt).

FunctionalStatement_Defines(irstmt, newVar, 0) :-
   Statement_Defines(stmt, newVar),
   Statement_IRStatement(stmt, irstmt).

// Case: variable originates elsewhere
FunctionalStatement_Uses(stmt, var, n) :-
   IRStatement_Uses_Local(stmt, stackIndex, n),
   CheckIsStackIndex(stackIndex),
   IRStatement_Block(stmt, block),
   FunctionalBlockInputContents(block, stackIndex, var).

.decl PublicFunctionSignature(hex_signature: Value, text_signature: symbol)
.input PublicFunctionSignature

.decl HighLevelFunctionName(func: Block, name: symbol)

// Standardize public function signature length
.decl SighashIntermediate(sig: symbol, sigHash: symbol)

SighashIntermediate(sigIn, cat("0x0",substr(sigOut,2,8))) :-
   SighashIntermediate(sigIn, sigOut),
   strlen(sigOut) < 10.

SighashIntermediate(sig, sig) :-
   PublicFunction(_, sig).

.decl PublicFunction_HighLevel(func: IRFunction, sigHashOut: symbol)
PublicFunction_HighLevel(func, sigHashOut) :-
   PublicFunction(func, sigHash),
   SighashIntermediate(sigHash, sigHashOut),
   strlen(sigHashOut) = 10.
   
HighLevelFunctionName(func, name) :-
   PublicFunction_HighLevel(func, sigHash),
   PublicFunctionSignature(sigHash, name).

HighLevelFunctionName(func, name) :-
   PublicFunction_HighLevel(func, name),
   !PublicFunctionSignature(name, _).

HighLevelFunctionName(func, func) :-
   Function(func),
   func != FUNCTION_SELECTOR,
   !PublicFunction(func, _).

HighLevelFunctionName(FUNCTION_SELECTOR, "__function_selector__").