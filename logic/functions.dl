#define FRESH_VARIABLE(var, stmt, stackIndex) (IRStatementNum((stmt), _stmtNum), var=-0xFFFF+_stmtNum*MAX_STACK_HEIGHT+(stackIndex))


#ifdef DEBUG
.output BlockEdge, FallthroughEdge, BlockJumpValidTarget, BlockJumpTarget, BasicBlock_Tail, MaybeInFunctionUnderContext
.output NotValidReturnBlock, NotValidReturnEdge
.output MaybeFunctionCallReturn // DEBUG
.output IsContext, CanReachUnderContext, CanReachUnderContextThroughBlock //DEBUG
.output PotentialCall // DEBUG
.output PossibleReturnAddress // DEBUG
.output IsFunctionCallReturn // DEBUG
.output IsFunctionEntry, IsFunctionCall, BlockToClone, MaybeInFunction // DEBUG
.output PossibleImpreciseNumberOfFunctionArguments

.output PossibleNumberOfFunctionArguments
.output PossibleNumberOfFunctionReturnArguments
.output PossibleCombinedNumberOfFunctionReturnsAndArguments
.output NumberOfFunctionArguments
.output NumberOfFunctionReturnArguments

.output Variable_String
#endif


/*****
 * Function discovery logic
 *****/

   
/******
         Generic basic block Reachable-from implementation
******/

.decl CanReachUnderContext(fromCtx: Context, from:Block, ctx: Context, block: Block)
CanReachUnderContext(ctx, block, ctx, block) :-
  ReachableContext(ctx, block).

CanReachUnderContext(ctxFrom, blockFrom, ctxTo, blockTo) :-
  CanReachUnderContext(ctxFrom, blockFrom, ctxOther, blockOther),
  BlockEdge(ctxOther, blockOther, ctxTo, blockTo).

.decl EnableCostlyAlgorithms()
EnableCostlyAlgorithms() :-
  n = count: CanReachUnderContext(_, _, _, _),
  n < 100000.

// The complement is useful when we need to include both alternatives in a .plan
.decl DisableCostlyAlgorithms()
DisableCostlyAlgorithms() :- !EnableCostlyAlgorithms().

// A very common combination, for scalability. Should only be used when "EnableCostlyAlgorithms" is true.
.decl CanReachUnderContextThroughBlock(fromCtx: Context, from:Block, through:Block, ctx: Context, block: Block)
CanReachUnderContextThroughBlock(fromCtx, from, through, ctx, block) :-
  CanReachUnderContext(fromCtx, from, throughCtx, through),
  EnableCostlyAlgorithms(), //place second for parallelism
  CanReachUnderContext(throughCtx, through, ctx, block).

// Derived from the context-sensitive version, maintains max precision when
// contexts aren't needed.
.decl CanReach(from:Block, block:Block)
CanReach(from, to) :-
  CanReachUnderContext(_, from, _, to).

/******
         Heuristics for detecting call-return patterns
******/

// A high-level call can only be translated into an immediate jump.
// More complex jumps (e.g., through basic blocks that just keep
// whatever was on the stack and jump to it) are technicalities for
// inlining.
.decl PotentialCall(caller:Block)
PotentialCall(block) :-
  postTrans.ImmediateBlockJumpTarget(block, _).


// Call-return pattern:
// a) basic block jumps to a valid "non-locally-derived" address
// b) address originates at a target-setter.
.decl PossibleReturnAddress(caller:Block, retBlock:Block, retTarget:Block)
PossibleReturnAddress(targetSetter, retBlock, retTarget) :-
  OptNotImmediateBlockJumpTarget(retBlock, targetVariable, retTarget),
  postTrans.Statement_Defines(targetSetStatement, targetVariable),
  postTrans.Statement_Block(targetSetStatement, targetSetter),
  postTrans.BasicBlock_Tail(targetSetter, jumpStmt),
  postTrans.JUMP(jumpStmt).

.decl OptNotImmediateBlockJumpTarget(ret:Block, targetVariable:Variable, retTarget:Block)
OptNotImmediateBlockJumpTarget(retBlock, targetVariable, retTarget) :-
  BlockJumpValidTarget(_, retBlock, targetVariable, retTarget),
  !postTrans.ImmediateBlockJumpTarget(retBlock, targetVariable).


// Also match a subset of those with return addresses and full info. The
// function may not be the one containing the return, in case of complex
// call patterns (e.g., call-call, or call-return).
.decl MaybeFunctionCallReturn(caller:Block, func:Block, retBlock:Block, retTarget:Block)

// Context-sensitive version
MaybeFunctionCallReturn(caller, func, retBlock, retTarget) :-
  PossibleReturnAddress(caller, retBlock, retTarget),
  EnableCostlyAlgorithms(), // place second for parallelism
  postTrans.ImmediateBlockJumpTarget(caller, targetVar),
  BlockJumpValidTarget(_, caller, targetVar, func),
  CanReachUnderContextThroughBlock(_, caller, func, retCtx, retBlock),
  CanReachUnderContext(retCtx, retBlock, _, retTarget).

// Insensitive version
MaybeFunctionCallReturn(caller, func, retBlock, retTarget) :-
  PossibleReturnAddress(caller, retBlock, retTarget),
  DisableCostlyAlgorithms(),
  postTrans.ImmediateBlockJumpTarget(caller, targetVar),
  BlockJumpValidTarget(_, caller, targetVar, func),
  CanReach(caller, retTarget),
  CanReach(func, retBlock).


// Seems pretty certain we found a return. In fact, at this point,
// with the above logic, we have detected all original return
// instructions in the code. There will be artificial returns added
// later, for calls that end up being tail calls.
// It's important to note that a statement may be a return with respect
// to one edge, but not with respect to others. There are many conditional
// returns.
.decl IsReturn(ret:Block, target:Block)
IsReturn(retBlock, retTarget) :-
  IsFunctionCallReturn(_, _, retBlock, retTarget).

// In this case the complete vs. precise version doesn't seem to be
// making much of a difference. 
.decl MaybeReturn(ret:Block, target:Block)
MaybeReturn(retBlock, retTarget) :-
  PossibleReturnAddress(_, retBlock, retTarget).


// Filtering for sanitization. The logic following can be arbitrarily
// restrictive. We have all potential calls and all returns, now we
// want to match them to each other and form cohesive functions (both
// for the caller and for the callee) only with very high certainty.

.decl FunctionCalledMultipleTimes(func: Block)
FunctionCalledMultipleTimes(func) :-
  MaybeFunctionCallReturn(caller, func, retBlock, _),
  MaybeFunctionCallReturn(caller2, func, retBlock, _),
  caller != caller2.

// Return block can only pertain to one function!
.decl NotValidReturnBlock(func: Block, retBlock: Block) 
NotValidReturnBlock(func, retBlock) :-
  MaybeFunctionCallReturn(_, func, retBlock, _),
  MaybeFunctionCallReturn(_, func2, retBlock, _),
  ord(func) < ord(func2).

/**
  If a block is a possible return of more than one functions, clone it in both
  Previous code had an invariant where a "return block can only pertain to one function!"
  which was problematic in many cases and could end up cloning blocks but not mark them as return blocks
**/
BlockToClone(retBlock, func):-
  MaybeFunctionCallReturn(_, func, retBlock, _),
  MaybeFunctionCallReturn(_, func2, retBlock, _),
  func != func2,
  func !=retBlock,
  func2 !=retBlock.

// Block reached from return edge cannot also be called directly
.decl NotValidReturnEdge(retBlock: Block, retTarget: Block)
NotValidReturnEdge(retBlock, retTarget) :-
  MaybeFunctionCallReturn(_, _, retBlock, retTarget),
  MaybeFunctionCallReturn(_, retTarget, _, _).

// Caller calls func and func returns to retTarget. Should only be inferred with
// high confidence.
.decl IsFunctionCallReturn(caller:Block, func:Block, retBlock:Block, retTarget:Block)
IsFunctionCallReturn(caller, func, retBlock, retTarget) :-
  MaybeFunctionCallReturn(caller, func, retBlock, retTarget),
  FunctionCalledMultipleTimes(func),
  //!NotValidReturnBlock(func, retBlock),
  !NotValidReturnEdge(retBlock, retTarget).



// NOTE the philosophy!  MaybeFunctionCallReturn intends to be
// complete, IsFunctionCallReturn intends to be precise.  Be careful when
// using the one vs. the other! Their balance is crucial.

/// Let's try something dead simple for assigning blocks to functions.

.decl IsFunctionEntry(entry:Block)
IsFunctionEntry(block) :- postTrans.PublicFunction(block, _).
IsFunctionEntry(FUNCTION_SELECTOR).
IsFunctionEntry(func) :- IsFunctionCallReturn(_, func, _, _).

.decl IsFunctionCall(block:Block, func:Block)
   
IsFunctionCall(prev, func) :-
   postTrans.PublicFunctionJump(prev, sigHash),
   postTrans.PublicFunction(func, sigHash).

// Use the precise version here!
IsFunctionCall(block, func) :-
  IsFunctionCallReturn(block, func, _, _).

// Precise context-sensitive reasoning
.decl MaybeInFunctionUnderContext(ctx: Context, block:Block, func:Block)
MaybeInFunctionUnderContext(ctx, block, block) :-
  IsFunctionEntry(block),
  ReachableContext(ctx, block).

MaybeInFunctionUnderContext(ctx, next, func) :-
  MaybeInFunctionUnderContext(prevCtx, block, func),
  BlockEdge(prevCtx, block, ctx, next),
  !IsFunctionCall(block, next),
  !IsReturn(block, next).

MaybeInFunctionUnderContext(ctx, next, func) :-
  OptMaybeInFunctionUnderContext(callerCtx, caller, func),
  EnableCostlyAlgorithms(), // place second for incrementality and parallelism
  // Use the complete version here!
  MaybeFunctionCallReturn(caller, callee, retBlock, next),
  // But add the same strict conditions as in its definition to find the context
  CanReachUnderContextThroughBlock(callerCtx, caller, callee, retCtx, retBlock),
  CanReachUnderContext(retCtx, retBlock, ctx, next).

MaybeInFunctionUnderContext(ctx, next, func) :-
  OptMaybeInFunctionUnderContext(callerCtx, caller, func),
  DisableCostlyAlgorithms(),
  // Use the complete version here!
  MaybeFunctionCallReturn(caller, _, _, next),
  CanReachUnderContext(callerCtx, caller, ctx, next). // still context-sensitive, but more scalable

.decl OptMaybeInFunctionUnderContext(callerCtx: Context, caller:Block, func:Block)
OptMaybeInFunctionUnderContext(callerCtx, caller, func) :-
  MaybeInFunctionUnderContext(callerCtx, caller, func),
  MaybeFunctionCallReturn(caller, _, _, _).


.decl MaybeInFunction(block:Block, func:Block)
MaybeInFunction(block, func) :-
  MaybeInFunctionUnderContext(_, block, func).

.decl BlockInMultipleFunctions(entry: Block)
BlockInMultipleFunctions(block) :-
  MaybeInFunction(block, func1),
  MaybeInFunction(block, func2),
  func1 != func2.


// For this function, the block should be inlined.
.decl BlockToClone(block: Block, func: Block)
BlockToClone(next, func) :-
  MaybeInFunction(next, func),
  BlockInMultipleFunctions(next),
  next != func. // don't clone function entries, other functions will clone them


/***********
 * Introduce new IR
 ***********/
#define FRESH_IRBLOCK(b, f) cat((b), (f))
#define FRESH_IRSTATEMENT(s, f) cat((s), (f))
#define BLOCK_TO_IRBLOCK CAST_TO_SYMBOL
#define STATEMENT_TO_IRSTATEMENT CAST_TO_SYMBOL
#define FUNCTION_TO_IRFUNCTION CAST_TO_SYMBOL
 
.type IRBlock
// exploit type checking in new IR
#define IRFunction IRBlock
.type IRStatement

.decl Block_IRBlock(block: Block, func: Block, irblock: IRBlock)
.decl Function_IRFunction(func: Block, irFunc: IRFunction)
.decl IRInFunction(block: IRBlock, func: IRFunction)
.decl IRFunctionEntry(irEntry: IRBlock)

// Let's first settle what belongs in which function,
// i.e., the nodes of our graph. Clone blocks as needed.

Function_IRFunction(funcentry, irEntry),
IRFunctionEntry(irEntry) :-
  IsFunctionEntry(funcentry),
  irEntry = FUNCTION_TO_IRFUNCTION(funcentry).

// Be loose in our demands for accepting a block as being in the same
// function.
Block_IRBlock(block, func, irblock),
IRInFunction(irblock, irFunc) :-
  MaybeInFunction(block, func),
  !BlockToClone(block, func),
  irblock = BLOCK_TO_IRBLOCK(block),
  Function_IRFunction(func, irFunc).

Block_IRBlock(block, func, irblock),
IRInFunction(irblock, irFunc) :-
  MaybeInFunction(block, func),
  BlockToClone(block, func),
  irblock = FRESH_IRBLOCK(block, func),
  Function_IRFunction(func, irFunc).

// Now let's settle the edges of the graph: which
// block is connected to which next one.

.decl IRFunction_Return_Edge(block: IRBlock, next: IRBlock)
.decl IRFunction_Return(fn: IRFunction, ret: IRBlock)
.decl IRFunctionCallReturn(caller: IRBlock, func: IRFunction, retcaller: IRBlock)

// Be strict in our precision demands for recognizing a call
IRFunction_Return(irfunc, retir),
IRFunctionCallReturn(callerir, irfunc, callerretir),
IRFunction_Return_Edge(retir, callerretir) :-
  IsFunctionCallReturn(caller, func, ret, callerret),
  Block_IRBlock(ret, func, retir),
  Block_IRBlock(caller, prevfunc, callerir),
  Block_IRBlock(callerret, prevfunc, callerretir),
  CanReach(caller, callerret),
  Function_IRFunction(func, irfunc),
  !BlockToClone(func, prevfunc).


// REVIEW: IRFunctionCall will include the IRFunctionCallReturn
// edges, i.e., the fully resolved calls, all the way to returns
// to the same caller function. Seems later stages can handle this?

.decl IRFunctionCall(from: IRBlock, func: IRFunction)
IRFunctionCall(fromir, irFunc) :-
  IsFunctionCall(from, func),
  Block_IRBlock(from, prevfunc, fromir),
  Function_IRFunction(func, irFunc),
  !BlockToClone(func, prevfunc).


// ///// This doesn't seem to be valid
// // Regular return instructions should also count as IR returns? For
// // use in possible #return values calculation.
// IRFunction_Return(irFunc, retBlock) :-
//   Statement_Opcode(stmt, "RETURN"),
//   Statement_IRStatement(stmt, func, irstmt),
//   IRBasicBlock_Tail(retBlock, irstmt),
//   Function_IRFunction(func, irFunc).


// Intra-function edges (i.e., real CFG edges)

//// WARNING: Be careful when using! This is an unintuitive
//// concept. It's only mapping the intra-procedural subset of
//// BlockEdges to the functional IR, not all BlockEdges. It's also
//// not the same as the "local" block edges of the functional IR,
//// because these also continue the function code after a call.
.decl IRBlockEdge(from: IRBlock, to: IRBlock)
IRBlockEdge(irfrom, irto) :-
  BlockEdge(ctxFrom, from, _, to),
  Block_IRBlock(from, func, irfrom),
  CanReachUnderContext(_, func, ctxFrom, from),
  !IsFunctionCallReturn(_, func, from, _),
  Block_IRBlock(to, func, irto).

.decl IRBlockPath(from: IRBlock, to: IRBlock)

IRBlockPath(irblk, irblk):-
  Block_IRBlock(_, _, irblk).

IRBlockPath(irfrom, irto):-
  IRBlockEdge(irfrom, irto).

IRBlockPath(block, next):-
  IRFunctionCallReturn(block, _, next).

IRBlockPath(irfrom, irto):-
  IRBlockPath(irfrom, irmid),
  IRBlockPath(irmid, irto).
  .plan 1:(2,1)

.decl ReachableFromFunHead(irblk:IRBlock)

ReachableFromFunHead(irblk):-
  Block_IRBlock(_, func, irblk),
  Block_IRBlock(func, func, irfunHead),
  IRBlockPath(irfunHead, irblk).

.decl InvalidIRBlockEdge(from: IRBlock, to: IRBlock)

InvalidIRBlockEdge(irfrom, irto):-
  IRBlockEdge(irfrom, irto),
  !ReachableFromFunHead(irto).

InvalidIRBlockEdge(irfrom, irto):-
  IRBlockEdge(irfrom, irto),
  !ReachableFromFunHead(irfrom).


.decl LocalBlockEdge(block: IRBlock, next: IRBlock)
LocalBlockEdge(irfrom, irto) :-
  IRBlockEdge(irfrom, irto),
  !InvalidIRBlockEdge(irfrom, irto).
LocalBlockEdge(block, next) :-
  IRFunctionCallReturn(block, _, next),
  ReachableFromFunHead(block).

.decl DeadBlock(irblk:IRBlock)
.decl DeadStmt(irstmt:IRStatement)

DeadBlock(irblk):-
  //(InvalidIRBlockEdge(irblk, _);InvalidIRBlockEdge(_, irblk)),
  Block_IRBlock(_, _, irblk),
  !ReachableFromFunHead(irblk).

DeadStmt(irstmt):-
  IRStatement_Block(irstmt, irblk),
  DeadBlock(irblk).

//
// The next few are mostly direct translations of concepts from the
// standard TAC IR to the Functional IR.
//

.decl IRFallthroughEdge(from: IRBlock, to: IRBlock)
IRFallthroughEdge(irfrom, irto) :-
  FallthroughEdge(from, to),
  Block_IRBlock(from, func, irfrom),
  Block_IRBlock(to, func, irto).


.decl Statement_IRStatement(stmt: Statement, func: Block, irstmt: IRStatement)
.decl IRStatement_Block(stmt: IRStatement, to: IRBlock)

.decl IRStatement_VarString(irstmt: IRStatement, func: symbol)
.decl IRBlock_VarString(irblock: IRBlock, str: symbol)
IRStatement_VarString(irstmt, irFunc),
IRBlock_VarString(irblock, irFunc),
IRStatement_Block(irstmt, irblock),
Statement_IRStatement(stmt, func, irstmt) :-
  BlockToClone(block, func),
  postTrans.Statement_Block(stmt, block),
  Block_IRBlock(block, func, irblock),
  Function_IRFunction(func, irFunc),
  irstmt = FRESH_IRSTATEMENT(stmt, func).

IRStatement_VarString(irstmt, ""),
IRBlock_VarString(irblock, ""),
IRStatement_Block(irstmt, irblock),
Statement_IRStatement(stmt, func, irstmt) :-
  Block_IRBlock(block, func, irblock),
  !BlockToClone(block, func),
  postTrans.Statement_Block(stmt, block),
  irstmt = STATEMENT_TO_IRSTATEMENT(stmt).

.decl IRStatementNum(stmt: IRStatement, num: number)
IRStatementNum(irstmt, num) :-
  postTrans._StatementNum(stmt, num),
  Statement_IRStatement(stmt, _, irstmt).

.decl IRTACNOP(stmt: IRStatement)
IRTACNOP(irstmt) :-
  postTrans.TACNOP(stmt),
  Statement_IRStatement(stmt, _, irstmt).

/***********
 * Identify actual function calls and returns
 ***********/

.decl FunctionCallStmt(irstmt: IRStatement)
FunctionCallStmt(irstmt) :-
  Block_IRBlock(block, func, irblock),
  IRFunctionCall(irblock, _),
  postTrans.BasicBlock_Tail(block, stmt),
  Statement_IRStatement(stmt, func, irstmt).

.decl FunctionReturnStmt(irstmt: IRStatement)
FunctionReturnStmt(irstmt) :-
  Block_IRBlock(block, func, irblock),
  IRFunction_Return(_, irblock),
  postTrans.BasicBlock_Tail(block, stmt),
  Statement_IRStatement(stmt, func, irstmt).

.decl IRStatement_Opcode(stmt: IRStatement, op: Opcode)
IRStatement_Opcode(irstmt, op) :-
  postTrans.Statement_Opcode(stmt, op),
  Statement_IRStatement(stmt, _, irstmt),
  !FunctionCallStmt(irstmt),
  !FunctionReturnStmt(irstmt).

IRStatement_Opcode(irstmt, "CALLPRIVATE") :-
  FunctionCallStmt(irstmt).

IRStatement_Opcode(irstmt, "RETURNPRIVATE") :-
  FunctionReturnStmt(irstmt).

.decl IRIsJump(stmt: IRStatement)
IRIsJump(irstmt) :-
  postTrans.IsJump(stmt),
  Statement_IRStatement(stmt, _, irstmt).


.decl IRBasicBlock_Tail(block: IRBlock, tail: IRStatement)
IRBasicBlock_Tail(irblock, irtail) :-
  postTrans.BasicBlock_Tail(block, tail),
  Block_IRBlock(block, func, irblock),
  Statement_IRStatement(tail, func, irtail),
  IRStatement_Block(irtail, irblock).


// Also translating concepts of how a block uses the stack
.decl IRBlockPopDelta(from: IRBlock, n: StackIndex)
.decl IRBlockStackDelta(from: IRBlock, stackDelta: StackIndex)

IRBlockPopDelta(irblock, n) :-
  postTrans.BlockPopDelta(block, n),
  Block_IRBlock(block, _, irblock).

IRBlockStackDelta(irblock, stackDelta) :-
  postTrans.BlockStackDelta(block, stackDelta),
  Block_IRBlock(block, _, irblock).

.decl IRStatement_Uses_Local(stmt: IRStatement, varOrStackIndex: VariableOrStackIndex, n: StackIndex)
IRStatement_Uses_Local(irstmt, varOrStackIndex, n) :-
  postTrans.Statement_Uses_Local(stmt, varOrStackIndex, n),
  Statement_IRStatement(stmt, _, irstmt).

.decl IRBeforeLocalStackContents(stmt: IRStatement, n:StackIndex, varOrStackIndex:VariableOrStackIndex)
IRBeforeLocalStackContents(irstmt, n, varOrStackIndex) :-
  postTrans.BeforeLocalStackContents(stmt, n, varOrStackIndex),
  Statement_IRStatement(stmt, _, irstmt).

.decl IRLocalStackContents(stmt: IRStatement, n:StackIndex, varOrStackIndex:VariableOrStackIndex)
IRLocalStackContents(irstmt, n, varOrStackIndex) :-
  postTrans.LocalStackContents(stmt, n, varOrStackIndex),
  Statement_IRStatement(stmt, _, irstmt).

.decl IRThrowJump(irstmt: IRStatement)
IRThrowJump(irstmt) :-
  postTrans.ThrowJump(stmt),
  Statement_IRStatement(stmt, _, irstmt).

.decl IRBlock_Gas(irblock: IRBlock, gas: number)
IRBlock_Gas(irblock, gas) :-
  Block_IRBlock(block, _, irblock),
  postTrans.Block_Gas(block, gas).


/***********
 * Discovery of arguments accepted by a function   
 ***********/

// New Instructions
// CALLPRIVATE(stmt, function)
// RETURNPRIVATE(stmt)

.decl NumberOfFunctionArguments(func: IRFunction, num: StackIndex)
.decl NumberOfFunctionReturnArguments(func: IRFunction, num: StackIndex)

// In the functional IR we have more kinds of (local) edges than in the TAC IR:
//  - Call-return edges from a block that ends in a call to the purported
//    continuation of the call
//  - Call edges that don't return (shown as edges to "invalid")
//  - return edges (also to "invalid")
//  - throw/exit edges (also to "invalid")
// We need to extend the stack-manipulation predicates for all those. Care
// should be taken for conditional calls.

// How many (max) elements are popped from the stack during this block transition?
.decl FunctionalBlockPopDelta(from: IRBlock, delta: StackIndex)

// Not a function call case
FunctionalBlockPopDelta(from, delta) :-
  IRBlockPopDelta(from, delta),
  !IRFunctionCall(from, _).


// The function needs n args, the caller block pops m and leaves the
// stack with d more than it found. This means n-d of the arguments
// are above the stack line the block got when it started.

// Case 1: If n-d >= m, then the combination block+call consumes
// (max) n-d stack elements, relative to the stack level at beginning
// of the caller block.
// Case 2: If n-d < m, then the combination block+call consumes m
// stack elements, relative to the stack level at beginning of the
// caller block.
FunctionalBlockPopDelta(from, newPopDelta) :-
  IRBlockPopDelta(from, popDelta),
  IRFunctionCall(from, func),
  PossibleImpreciseNumberOfFunctionArguments(func, n_args),
  IRBlockStackDelta(from, stackDelta),
  tempPopDelta = n_args-stackDelta,
  tempPopDelta < MAX_STACK_HEIGHT,
  ((tempPopDelta >= popDelta, newPopDelta = tempPopDelta);
   (tempPopDelta < popDelta, newPopDelta = popDelta)).


// What is the total difference in stack level during this block ?
.decl FunctionalBlockStackDelta(from: IRBlock, delta: StackIndex)

// Not a call
FunctionalBlockStackDelta(from, stackDelta) :-
  !IRFunctionCall(from, _),
  IRBlockStackDelta(from, stackDelta).

// It's a call-with-return edge
FunctionalBlockStackDelta(from, newStackDelta) :-
  IRFunctionCallReturn(from, func, _),
  IRFunction_Return(func, ret),
  PossibleCombinedNumberOfFunctionReturnsAndArguments(func, ret, n_args, n_ret),
  IRBlockStackDelta(from, stackDelta),
  newStackDelta = stackDelta - n_args + n_ret,
  newStackDelta < MAX_STACK_HEIGHT,
  newStackDelta > -MAX_STACK_HEIGHT.

// What about calls with no return? These don't get back to the
// caller, so we never care about the level they leave the stack at,
// only about how deep in it they went.

.decl IsImportantBlock(block: IRBlock)

IsImportantBlock(block) :-
   LocalBlockEdge(prev, block),
   LocalBlockEdge(prev2, block),
   !LocalBlockEdge(prev, prev2),
   !LocalBlockEdge(prev2, prev),
   prev != prev2.



// What's the total pop and stack delta since the beginning of the
// function for (probably) cycle-free paths? Clearly these can have
// multiple values. We need to keep track of all nodes avoided in the
// path so far, so that we can extend the path cycle-free. We also
// need to ensure both cumulative deltas are true for the *same* path,
// not just different paths to the same end node. This makes for
// complex rules.
.decl PossibleFunctionalBlockPopAndStackDelta(func: IRFunction, from: IRBlock, path: symbol, popDelta: StackIndex, stackDelta: StackIndex)

// Another auxiliary for optimization: avoid join in key innermost loop
.decl FunctionalBlockPopAndStackDelta(from: IRBlock, popDelta:StackIndex, stackDelta:StackIndex)
FunctionalBlockPopAndStackDelta(from, popDelta, stackDelta) :-
  FunctionalBlockPopDelta(from, popDelta),
  FunctionalBlockStackDelta(from, stackDelta).
.plan 1:(2,1)

PossibleFunctionalBlockPopAndStackDelta(from, from, from, 0, 0) :-
  IRFunctionEntry(from).


// rules added for optimization purposes
.decl ImportantLocalBlockEdge(from: IRBlock, to: IRBlock)

ImportantLocalBlockEdge(from, to) :-
   LocalBlockEdge(from, to),
   IsImportantBlock(to).

.decl UnimportantLocalBlockEdge(from: IRBlock, to: IRBlock)
UnimportantLocalBlockEdge(from, to) :-
   LocalBlockEdge(from, to),
   !IsImportantBlock(to).

#define WITHIN_STACK_LIMIT(n) (n < MAX_STACK_HEIGHT, n > -MAX_STACK_HEIGHT)

PossibleFunctionalBlockPopAndStackDelta(func, to, newPath, newPopDelta, newStackDelta) :-
  PossibleFunctionalBlockPopAndStackDelta(func, from, prevPath, prevPopDelta, prevStackDelta),
  ImportantLocalBlockEdge(from, to),
  FunctionalBlockPopAndStackDelta(from, popDelta, stackDelta),                      
  tempPopDelta = popDelta - prevStackDelta,
  ((tempPopDelta > prevPopDelta, newPopDelta = tempPopDelta);
   (tempPopDelta <= prevPopDelta, newPopDelta = prevPopDelta)),
  newStackDelta = stackDelta + prevStackDelta,
  WITHIN_STACK_LIMIT(newPopDelta), WITHIN_STACK_LIMIT(newStackDelta),
  newPath = @add_set(prevPath, to),
  newPath != prevPath.
  .plan 1:(3,2,1)

PossibleFunctionalBlockPopAndStackDelta(func, to, prevPath, newPopDelta, newStackDelta) :-
  PossibleFunctionalBlockPopAndStackDelta(func, from, prevPath, prevPopDelta, prevStackDelta),
  UnimportantLocalBlockEdge(from, to),
  FunctionalBlockPopAndStackDelta(from, popDelta, stackDelta),
  tempPopDelta = popDelta - prevStackDelta,
  ((tempPopDelta > prevPopDelta, newPopDelta = tempPopDelta);
   (tempPopDelta <= prevPopDelta, newPopDelta = prevPopDelta)),
  newStackDelta = stackDelta + prevStackDelta,
  WITHIN_STACK_LIMIT(newPopDelta), WITHIN_STACK_LIMIT(newStackDelta).
  .plan 1:(3,2,1)


// Combine both relative to a single terminal point, for precision.
// We need to go one edge back to make sure it's a terminal point
// (return, call-with-no-return, or throw, possibly conditionally),
// then add the delta again. Tedious.
.decl PossibleCombinedNumberOfFunctionReturnsAndArguments(func: IRFunction, terminal: IRBlock, numArg: StackIndex, numRet: StackIndex)

PossibleCombinedNumberOfFunctionReturnsAndArguments(func, terminal, numArg, numRet) :-
  PossibleFunctionalBlockPopAndStackDelta(func, terminal, _, prevPopDelta, prevStackDelta),
  FunctionalBlockPopAndStackDelta(terminal, popDelta, stackDelta),
  newPopDelta = popDelta - prevStackDelta,
  WITHIN_STACK_LIMIT(newPopDelta),
  ((newPopDelta > prevPopDelta, numArg = newPopDelta);
   (newPopDelta <= prevPopDelta, numArg = prevPopDelta)),
  numRet = prevStackDelta + stackDelta + numArg,
  numRet < MAX_STACK_HEIGHT, numRet >= 0. 
    // When leaving the stack with d more items but it originally
    // contained a args, the total number of returned values is d+a.
 .plan 1:(2,1)


// Simple, imprecise over-estimate computation that doesn't incur
// cycle-through-aggregation problem, so it can be used in edge
// inferences.
.decl PossibleImpreciseNumberOfFunctionArguments(func: IRFunction, num: StackIndex)
PossibleImpreciseNumberOfFunctionArguments(func, numArg) :-
  PossibleCombinedNumberOfFunctionReturnsAndArguments(func, _, numArg, _).


// Our more precise inferences
.decl PossibleNumberOfFunctionArguments(func: IRFunction, num: StackIndex)
.decl PossibleNumberOfFunctionReturnArguments(func: IRFunction, num: StackIndex)

// Either a call with no return, or a return, or a throw: all are valid
PossibleNumberOfFunctionArguments(func, n) :-
  IRInFunction(block, func),
  !LocalBlockEdge(block, _),
  n = min numArg: PossibleCombinedNumberOfFunctionReturnsAndArguments(func, block, numArg, _).

PossibleNumberOfFunctionReturnArguments(func, n) :-
  IRFunction_Return(func, ret),
  n = min numRet: PossibleCombinedNumberOfFunctionReturnsAndArguments(func, ret, _, numRet).
  
  
// REVIEW: do we need defaults of 0? I don't see why. But it won't hurt as
// long as we are taking the max.
PossibleNumberOfFunctionArguments(func, 0),
PossibleNumberOfFunctionReturnArguments(func, 0) :-
  IRFunctionEntry(func).

NumberOfFunctionArguments(FUNCTION_SELECTOR, 0).

NumberOfFunctionArguments(func, n) :-
  IRFunctionEntry(func),
  func != FUNCTION_SELECTOR,
  n = max m : PossibleNumberOfFunctionArguments(func, m).

NumberOfFunctionReturnArguments(func, n) :-
  IRFunctionEntry(func),
  n = max m : PossibleNumberOfFunctionReturnArguments(func, m).


.decl Variable_String(var:Variable, var_rep:symbol)

.decl Variable_Stmt_String(var:Variable, stmt: IRStatement, var_rep:symbol) inline

Variable_Stmt_String(var, stmt, res) :-
   res = cat(_stmt_str, _var_str),
   IRStatement_VarString(stmt, _stmt_str),
   Variable_String(var, _var_str).
        
.decl Variable_Block_String(var:Variable, block: IRBlock, var_rep:symbol) inline

Variable_Block_String(var, block, res) :-
   res = cat(_block_str, _var_str),
   IRBlock_VarString(block, _block_str),
   Variable_String(var, _var_str).


.decl FunctionArgument(func: IRFunction, n: StackIndex, var: Variable)
.decl FunctionCallReturnArgument(func: IRBlock, n: StackIndex, var: Variable)

.decl FunctionalStatement_Uses_Local(stmt: IRStatement, var:VariableOrStackIndex, n:StackIndex)
.decl FunctionalStatement_Uses(stmt:IRStatement, var:Variable, n:StackIndex)
.decl FunctionalStatement_Defines(callStmt:IRStatement, newVar:Variable, n: number)


Variable_String(var, var_rep) :-
   postTrans.Statement_Defines(var_rep, var).

Variable_String(var, cat(func, cat("arg", @number_to_hex(n)))),
FunctionArgument(func, n, var) :-
//// REVIEW
//  PossibleNumberOfFunctionArguments(func, n_args),
  FunctionArgumentIndices(func, n),
  FRESH_VARIABLE(var, BLOCK_TO_IRBLOCK(func), n). // TODO: use entry?

.decl FunctionArgumentIndices(func: IRFunction, n: number)

FunctionArgumentIndices(func, n) :-
  NumberOfFunctionArguments(func, n_args),
  IsStackIndexLessThan(n, n_args).


Variable_String(newVar, cat(callStmtBefore, cat("_", @number_to_hex(n)))),
FunctionalStatement_Defines(callStmt, newVar, n),
FunctionCallReturnArgument(caller, n, newVar) :-
  IRFunctionCall(caller, func),
//// REVIEW
  FunctionReturnArgumentIndices(func, n),
  IRBasicBlock_Tail(caller, callStmt),
  Statement_IRStatement(callStmtBefore, _ ,callStmt),
  FRESH_VARIABLE(newVar, callStmt, n).

.decl FunctionReturnArgumentIndices(func: IRFunction, n: number)

FunctionReturnArgumentIndices(func, n) :-
  NumberOfFunctionReturnArguments(func, n_args),
  IsStackIndexLessThan(n, n_args).

// Renaming variables in functions
// Involves Propagating variables, but doesn't require re-computing the CFG
.decl FunctionalBlockInputContents(block:IRBlock, index:number, var:Variable)
.decl FunctionalBlockOutputContents(block:IRBlock, index:number, var:Variable)

FunctionalBlockInputContents(entry, n, var) :-
   IRFunctionEntry(entry),
   IRInFunction(entry, func),
   FunctionArgument(func, n, var).

FunctionalBlockInputContents(next, index, variable) :-
   FunctionalBlockOutputContents(from, index, variable),
   LocalBlockEdge(from, next).

// 1) Normal block to block flow, i.e. no unconditional function calls from block to block
FunctionalBlockOutputContents(block, index, variable) :-
  BeforeFunctionCallFunctionalBlockOutputContents(block, index, variable),
  LocalBlockEdge(block, next),
  IRBlockEdge(block, next).

// 2) First block calls a function, take return args from function call

FunctionalBlockOutputContents(caller, n, newVar) :-
   FunctionCallReturnArgument(caller, n, newVar).

// 3) First block calls a function, take any remaining variables that have
//    not been passed as arguments, and shift
FunctionalBlockOutputContents(caller, newIndex, variable) :-
   BeforeFunctionCallFunctionalBlockOutputContents(caller, index, variable),
   IRFunctionCallReturn(caller, func, _),
//   PossibleCombinedNumberOfFunctionReturnsAndArguments(func, n_in, n_out),
////REVIEW
   NumberOfFunctionReturnArguments(func, n_out),
   NumberOfFunctionArguments(func, n_in),
   index >= n_in,
   newIndex = index+n_out-n_in,
   newIndex >= 0,
   newIndex < MAX_STACK_HEIGHT.

.decl BeforeFunctionCallFunctionalBlockOutputContents(caller: IRBlock, index: StackIndex, variable: Variable)

// Copy the stack variables untouched by the callee basic block
BeforeFunctionCallFunctionalBlockOutputContents(callee, index+delta, variable) :-
  FunctionalBlockInputContents(callee, index, variable),
  index >= calleePopLen,
  index+delta <= MAX_STACK_HEIGHT,
  IRBlockPopDelta(callee, calleePopLen),
  IRBlockStackDelta(callee, delta).

// Handle the proper variables pushed by this basic block
BeforeFunctionCallFunctionalBlockOutputContents(block, index, var) :-
  IRInFunction(block, _),
  IRBasicBlock_Tail(block, stmt),
  IRLocalStackContents(stmt, index, var),
  CheckIsVariable(var).

// Handle the stackIndexes pushed by this basic block
BeforeFunctionCallFunctionalBlockOutputContents(block, index, realVariable) :-
  FunctionalBlockInputContents(block, stackIndex, realVariable),
  IRBasicBlock_Tail(block, stmt),
  IRLocalStackContents(stmt, index, stackIndex),
  CheckIsStackIndex(stackIndex).


// TODO, check case for function call
FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
  IRFunctionCall(block, func),
  IRBasicBlock_Tail(block, stmt),
  IRStatement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, m),
//// REVIEW
//  PossibleNumberOfFunctionArguments(func, n_in),
  NumberOfFunctionArguments(func, n_in),
  IsStackIndexLessThan(n, m+n_in),
  IRBeforeLocalStackContents(stmt, n, varOrStackIndex).

// TODO, check case for function return
FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
//// REVIEW
  NumberOfFunctionReturnArguments(func, n_out),
  IRFunction_Return(func, retBlock),
  IRBasicBlock_Tail(retBlock, stmt),
  IRStatement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, m),
  IsStackIndexLessThan(n, m+n_out),
  IRBeforeLocalStackContents(stmt, n, varOrStackIndex).

FunctionalStatement_Uses_Local(irstmt, varOrStackIndex, n) :-
   postTrans.Statement_Uses_Local(stmt, varOrStackIndex, n),
   Statement_IRStatement(stmt, _, irstmt).

FunctionalStatement_Uses(irstmt, var, n) :-
   postTrans.Statement_Uses_Local(stmt, var, n),
   CheckIsVariable(var),
   Statement_IRStatement(stmt, _, irstmt).

FunctionalStatement_Defines(irstmt, newVar, 0) :-
   postTrans.Statement_Defines(stmt, newVar),
   Statement_IRStatement(stmt, _, irstmt).

// Case: variable originates elsewhere
FunctionalStatement_Uses(stmt, var, n) :-
   IRStatement_Uses_Local(stmt, stackIndex, n),
   CheckIsStackIndex(stackIndex),
   IRStatement_Block(stmt, block),
   FunctionalBlockInputContents(block, stackIndex, var).

.decl PublicFunctionSignature(hex_signature: Value, text_signature: symbol)
.input PublicFunctionSignature

PublicFunctionSignature("0x00000000", "fallback()").

.decl HighLevelFunctionName(func: IRFunction, name: symbol)

// Standardize public function signature length
.decl SighashIntermediate(sig: symbol, sigHash: symbol)

SighashIntermediate(sigIn, cat("0x0",substr(sigOut,2,8))) :-
   SighashIntermediate(sigIn, sigOut),
   strlen(sigOut) < 10.

SighashIntermediate(sig, sig) :-
   postTrans.PublicFunction(_, sig).

.decl IRPublicFunction(irfunc: IRFunction, sigHash: Value)
IRPublicFunction(irfunc, sigHash) :-
  postTrans.PublicFunction(func, sigHash),
  Function_IRFunction(func, irfunc).
  
.decl PublicFunction_HighLevel(func: IRFunction, sigHashOut: symbol)
PublicFunction_HighLevel(func, sigHashOut) :-
   IRPublicFunction(func, sigHash),
   SighashIntermediate(sigHash, sigHashOut),
   strlen(sigHashOut) = 10.
   
HighLevelFunctionName(func, name) :-
   PublicFunction_HighLevel(func, sigHash),
   PublicFunctionSignature(sigHash, name).

HighLevelFunctionName(func, name) :-
   PublicFunction_HighLevel(func, name),
   !PublicFunctionSignature(name, _).

HighLevelFunctionName(func, func) :-
   IRFunctionEntry(func),
   func != FUNCTION_SELECTOR,
   !IRPublicFunction(func, _).

HighLevelFunctionName(FUNCTION_SELECTOR, "__function_selector__").
