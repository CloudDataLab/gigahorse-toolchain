.type Context = [ block:Block, rest:Context ]

// find number of jumps to estimate best context depth

.decl NumberOfJumps(n: number)

NumberOfJumps(n1 + n2) :-
   n1 = count : JUMP(_),
   n2 = count : JUMPI(_).

#define ESTIMATE_DEPTH(n) (2000 / (n))

.decl MaxContextDepth(d: number)
MaxContextDepth(m) :-
   NumberOfJumps(n),
   m = ESTIMATE_DEPTH(n),
   m > 0, m < 15.

MaxContextDepth(1) :-
   NumberOfJumps(n),
   m = ESTIMATE_DEPTH(n),
   m <= 0.

MaxContextDepth(15) :-
   NumberOfJumps(n),
   m = ESTIMATE_DEPTH(n),
   m >= 15.

.output MaxContextDepth

.decl InitialContext(ctx : Context)
InitialContext(nil).

.decl ContextDepth(ctx : Context, depth : number)
ContextDepth(init, 0) :-
  InitialContext(init).

.decl IsContext(rest:Context)
IsContext(nil).

.decl DropLast(ctx : Context, newCtx : Context)
DropLast(ctx, nil) :-
  IsContext(ctx),
  ctx = [ block, nil ], block = block.

IsContext(newCtx),
DropLast(ctx, newCtx) :-
  IsContext(ctx),
  ctx = [ block, rest ],
  DropLast(rest, newRest),
  newCtx = [ block, newRest ].


.decl MergeContext(ctx : Context, caller : Block, newContext : Context)

ContextDepth(newContext, depth + 1),
MergeContext(ctx, caller, newContext),
IsContext(newContext) :-
  ReachableContext(ctx, caller),
  ContextDepth(ctx, depth),
  MaxContextDepth(maxDepth),
  depth < maxDepth,
  newContext = [caller, ctx].

ContextDepth(newContext, depth),
MergeContext(ctx, caller, newContext),
IsContext(newContext) :-
  ReachableContext(ctx, caller),
  ContextDepth(ctx, depth),
  MaxContextDepth(depth),
  DropLast(ctx, cutDownCtx),
  newContext = [caller, cutDownCtx].
