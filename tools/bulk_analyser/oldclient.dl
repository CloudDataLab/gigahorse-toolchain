

// OUTPUT

// REENTRANCY

// Holds if the statement is protected by a mutex.
// Note: the domination line might be too strong. A protected statement must
//       have mutex checks at all incoming paths, of which there may be multiple.
// Possible improvements:
//   Check if the values being written are the right ones:
//     writing true to set the mutex, then read true leads to throw to check it.
//   Multiple mutexes across different paths (c.f. solarstorm),
//   A mutex only needs to be checked and not set if state is just being written to,
//     if there are no possible reentrant calls on a given path.
//   Specify that the mutex location values MUST match (i.e. only one possible value)

.decl protectedByLoc(protectedStmt:Statement, sLoc:Value)
protectedByLoc(protectedStmt, sLoc) :- controlsWith(controlStmt, protectedStmt, condVar),
		            dom(setMutexStmt, controlStmt),
		            dom(protectedStmt, setMutexStmt),
                   	    depends(condVar, mutexResVar),
			    stateReadResult(mutexResVar, readMutexStmt),
			    op(readMutexStmt, "SLOAD"),
			    use(readMutexLoc, readMutexStmt, _),
			    op_SSTORE(setMutexStmt, setMutexLoc, _),
			    value(readMutexLoc, sLoc),
			    value(setMutexLoc, sLoc).

// A statement is considered gassy if it uses some variable that depends on a GAS operation
.decl gassy(stmt:Statement, var:Variable)
gassy(stmt, var) :- use(var, stmt, _), depends(var, gasVar), gasResult(gasVar, _).

// Could also check whether the gas is higher than some manually-set gas threshold.
.decl reentrantCall(stmt: Statement)
.output reentrantCall
reentrantCall(stmt) :- op(stmt, "CALL"), !protectedByLoc(stmt, _), gassy(stmt, gasVar), op_CALL(stmt, gasVar, _, _, _, _, _, _).


// ORIGIN

// Dependency from the origin opcode to an actual use of it.
.decl originUsed(stmt:Statement)
.output originUsed
originUsed(stmt) :- originResult(originVar, stmt), depends(useVar, originVar),
		    usedInStateOrCond(useVar, stmt).

// UNCHECKED SEND

.decl checkedCallThrows(callStmt:Statement)
.output checkedCallThrows
checkedCallThrows(callStmt) :- callResult(resVar, callStmt), depends(cond, resVar),
			       controlsWith(_, throwStmt, cond), isThrow(throwStmt).
checkedCallThrows(callStmt) :- callResult(resVar, callStmt), depends(cond, resVar),
			       use(cond, throwStmt, _), isThrow(throwStmt).

.decl checkedCallStateUpdate(callStmt:Statement)
.output checkedCallStateUpdate
checkedCallStateUpdate(callStmt) :- callResult(resVar, callStmt), depends(cond, resVar),
			            controlsWith(_, storeStmt, cond), op(storeStmt, "SSTORE").
checkedCallStateUpdate(callStmt) :- callResult(resVar, callStmt), depends(stateVar, resVar),
				    use(stateVar, storeStmt, _), op(storeStmt, "SSTORE").

