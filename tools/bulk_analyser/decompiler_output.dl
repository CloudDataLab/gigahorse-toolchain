.output IsBasicBlockHead
.output IsBasicBlockTail
.output PushValue
.output Statement_Defines
.output Statement_Uses

// Fills disk too quickly
//.output BlockOutputContents


.decl InsBlockEdge(from: Statement, to:Statement)
.output InsBlockEdge

        
InsBlockEdge(from, to) :-
  BlockEdge(_, [from], _, [to]).

.output Statement_BlockHead
.output Statement_Opcode
        
.decl InsBlockJumpTarget(stmt:Statement, target: symbol)
.output InsBlockJumpTarget       

InsBlockJumpTarget(headStmt, target) :-
  block = [headStmt],
  ReachableContext(ctx, block),
  BlockJumpValidTarget(ctx, block, _, [target]).

.decl PolymorphicTarget(headStmt: Statement)
.output PolymorphicTarget      

PolymorphicTarget(headStmt) :-
  InsBlockJumpTarget(headStmt, target1),
  InsBlockJumpTarget(headStmt, target2),
  target1 != target2.

.decl BlockJumpAnyTarget(headStmt:Statement)
.output BlockJumpAnyTarget

BlockJumpAnyTarget(headStmt) :-
  BlockJumpTarget(ctx, [headStmt], targetVar),
  Variable_Value(targetVar, target),
  (DynamicValue(target) ; AnyValue(target)).

.decl InsensBlockInputContents(block:Statement, index:number, var:Variable)
.output InsensBlockInputContents

InsensBlockInputContents(block, index, var) :-
  BlockInputContents(_, [block], index, var).

.decl TosOutput(stmt: Statement, abc:symbol, valueOrAlias:number, xyz:symbol, opcode:symbol, delta:number)
.output TosOutput      

TosOutput(stmt, "::", valueOrAlias, "<-", opcode, delta) :-
  LocalStackContents(stmt, 0, valueOrAlias),
  Statement_Opcode(stmt, opcode),
  StatementStackDelta(stmt, delta).

.decl MissingInfo(stmt:Statement, opcode:Opcode)
.output MissingInfo

MissingInfo(stmt, opcode) :-
  Statement_Opcode(stmt, opcode),
  OpcodePushWords(opcode, n), n>0,
  !LocalStackContents(stmt, 0, _),
  !OpcodePossiblyHalts(opcode).

.decl PublicFunctionEntryOut(stmt: Statement, sigHash: Value)
.output PublicFunctionEntryOut

PublicFunctionEntryOut(stmt, sigHash) :-
  PublicFunctionEntry([stmt], sigHash).


/*
 ***********
 * Auxiliary relations: Dominance frontiers for optimal PHI instruction placement
 ***********
 */

// Both arguments are basic block heads
// There is a path from the entry to s that does not go through candidate
.decl DoesNotDominate(candidate:Block, s:Block)

DoesNotDominate(candidate, ["0x0"]) :-
  Statement_Block(_, candidate),
  candidate != ["0x0"].

DoesNotDominate(candidate,s) :-
  DoesNotDominate(candidate,other),
  BlockEdge(_, s, _, other),
  s != candidate.

.decl Exit(block:Block)

Exit(block) :- Statement_Block(_, block), !BlockEdge(_, block, _, _).

// Both arguments are basic block heads
// There is a path from s to the exit that does not go through candidate
.decl DoesNotPostDominate(candidate: Block, s: Block)

DoesNotPostDominate(candidate, exitNode) :-
  Exit(exitNode),
  Statement_Block(_, candidate).

DoesNotPostDominate(candidate,s) :-
  DoesNotPostDominate(candidate,other),
  BlockEdge(_, other, _, s),
  s != candidate.

// The Dominates/PostDominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions would be expensive.
.decl Dominates(dominator:Block, s:Block)

Dominates(dominator,s) :-
  Statement_Block(_, dominator),
  Statement_Block(_, s),
  !DoesNotDominate(dominator,s).

.decl PostDominates(postdominator:Block, s:Block)
PostDominates(postdominator,s) :-
  Statement_Block(_, postdominator),
  Statement_Block(_, s),
  !DoesNotPostDominate(postdominator,s).

.decl DominatorFrontier(block: Block, frontier: Block)
// AFAIK a block f is a frontier of b if b dominates f
// but not f's predecessors

DominatorFrontier(block, frontier) :-
  Dominates(frontier, block),
  BlockEdge(_, pred, _, frontier),
  !Dominates(pred, block).

.decl PolymorphicAlias(block: Block, alias: Alias, newVarSymbol: symbol)

// Find all polymorphic aliases
// These need phi instructions introduced at the dominance frontier
PolymorphicAlias(block, alias, cat(cat(blockStr, "_"), aliasStr)) :-
  FunctionalBlockInputContents(block, alias, var1),
  FunctionalBlockInputContents(block, alias, var2),
  var1 != var2,
  Statement_Block(stmt, block),
  FunctionalStatement_Uses_Local(stmt, alias, _),
  block = [blockStr],
  AliasToString(alias, aliasStr).

.symbol_type TACVariable

// Final decompiler outputs
.decl TAC_Op(stmt:Statement, op:Opcode)
.output TAC_Op             
.decl TAC_Stmt(stmt:Statement)
.output TAC_Stmt
.decl TAC_Use(stmt: Statement, var: TACVariable, i: number)
.output TAC_Use
.decl TAC_Def(stmt: Statement, var: TACVariable, n: number)
.output TAC_Def
.decl TAC_Var(var: TACVariable)
.output TAC_Var
.decl TAC_Block(block: Statement, stmt: Statement)
.output TAC_Block
.decl TAC_Variable_Value(var: TACVariable, Value: symbol)
.output TAC_Variable_Value

// Normal variable, known length
TAC_Variable_Value(stmt, value) :-
   FunctionalStatement_Defines(stmt, var, _),
   Variable_Value(var, value).

UnknownLength(var) :-
  (FunctionalStatement_Defines(stmt, var, _) ;
  FunctionalStatement_Uses(stmt, var, _)),
  !Variable_Length(var, _).

// Normal variable, unknown length
TAC_Variable_Length(stmt, 32) :-
   (FunctionalStatement_Defines(stmt, var, _) ;
    FunctionalStatement_Uses(stmt, var, _)),
   UnknownLength(var).

// phi variable, unknown length
TAC_Variable_Length(stmt, 32) :-
  PolymorphicAlias(block, alias, phiStmt),
  FunctionalBlockInputContents(block, alias, var),
  UnknownLength(var).

TAC_Variable_Length(stmt, maxLength) :-
  PolymorphicAlias(block, alias, phiStmt),
  FunctionalBlockInputContents(block, alias, var),
  maxLength = max length: Variable_Length(var, length),
  !UnknownLength(var).

// New Instructions
// *returnArgs = CALLPRIVATE(stmt, function, *args)
// *returnArgs = CALLPRIVATEI(cond, stmt, function, *args)
// RETURNPRIVATE(stmt, *args)

// Non-nop instructions
TAC_Stmt(stmt) :-
  Statement_Opcode(stmt, _),
  !TACNOP(stmt).

TAC_Op(stmt, op) :-
   Statement_Opcode(stmt, op),
   !TACNOP(stmt),
   !FunctionCallStmt(stmt),
   !FunctionReturnStmt(stmt),
   !PushValue(stmt, _).

TAC_Op(stmt, "CONST") :-
   PushValue(stmt, _).

TAC_Op(stmt, "CALLPRIVATEI") :-
   JUMPI(stmt),
   FunctionCallStmt(stmt).

TAC_Op(stmt, "CALLPRIVATE") :-
   JUMP(stmt),
   FunctionCallStmt(stmt).

TAC_Op(stmt, "RETURNPRIVATEI") :-
   JUMPI(stmt),
   FunctionReturnStmt(stmt).

TAC_Op(stmt, "RETURNPRIVATE") :-
   JUMP(stmt),
   FunctionReturnStmt(stmt).

TAC_Op(stmt, op) :-
   FunctionReturnStmt(stmt),
   Statement_Opcode(stmt, op),
   !JUMP(stmt),
   !JUMPI(stmt).
   
// Phi instructions
TAC_Var(stmt),
TAC_Def(stmt, stmt, 0),
TAC_Stmt(stmt),
TAC_Op(stmt, "PHI") :-
  PolymorphicAlias(_, _, stmt).

// Non-phi, non-call variable id same as stmt it is defined in
TAC_Var(var_rep),
TAC_Def(stmt, var_rep, n) :-
   FunctionalStatement_Defines(stmt, var, n),
   Variable_String(var, var_rep).

// Case 1: Uses locally defined variable
TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, var, n),
  CheckIsVariable(var),
  Variable_String(var, var_rep).

// Case 2: Uses monomorphic global var
TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, alias, n),
  CheckIsAlias(alias),
  Statement_Block(stmt, block),
  !PolymorphicAlias(block, alias, _),
  FunctionalBlockInputContents(block, alias, var),
  Variable_String(var, var_rep).

// Case 3: Is a PHI statement
PHI_Uses(phiStmt, var_rep),
TAC_Use(phiStmt, var_rep, -1) :-
  PolymorphicAlias(block, alias, phiStmt),
  FunctionalBlockInputContents(block, alias, var),
  Variable_String(var, var_rep).

// Case 4: Uses polymorphic variable
TAC_Use(stmt, var_rep, n) :-
  FunctionalStatement_Uses_Local(stmt, alias, n),
  CheckIsAlias(alias),
  Statement_Block(stmt, block),
  PolymorphicAlias(block, alias, var_rep).

TAC_Block(block, stmt) :-
  Statement_Block(stmt, [block]),
  !TACNOP(stmt).

TAC_Block(block, phiStmt) :-
  PolymorphicAlias([block], _, phiStmt).
//   DominatorFrontier([block], [frontier]).



/***********
 *  Function-discovery outputs to visualization scripts
 ***********/

.decl FunctionCall_Out(caller:symbol, func:symbol)
.output FunctionCall_Out

FunctionCall_Out(caller, func) :-
  FunctionCall([caller], [func]).

.decl FunctionCallReturn_Out(caller:symbol, func:symbol, retTarget:symbol)
.output FunctionCallReturn_Out
        
.decl Function_Return_Out(func:symbol, retBlock:symbol)
.output Function_Return_Out

.decl Function_Out(func: symbol)
.output Function_Out

FunctionCallReturn_Out(caller, func, retTarget) :-
  FunctionCallReturn([caller], [func], [retTarget]).

Function_Out(func) :- Function([func]).

Function_Return_Out(func, retBlock) :-
   Function_Return([func], [retBlock]).

.decl FunctionArgument_Out(func:symbol, var:symbol, n:number)
.output FunctionArgument_Out

FunctionArgument_Out(func, var_rep, n) :-
   FunctionArgument([func], n, var),
   Variable_String(var, var_rep).

.decl LocalBlockEdge_Out(from: symbol, to: symbol)
.output LocalBlockEdge

LocalBlockEdge_Out(from, to) :-
   LocalBlockEdge([from], [to]).
