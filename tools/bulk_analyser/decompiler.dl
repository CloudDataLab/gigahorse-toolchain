#include "decompiler_inputs.dl"

#define MaxStackHeight 1024

.type Statement
.type Block = [ head:Statement ]
.type Value
.type Opcode
.type Alias = number

// We want a sum, but sum types crash, so we use a product
.type ValueOrAlias = [ alias:Alias, value:Value ]

.decl Statement_Opcode(statement: Statement, opcode: Opcode)
.input Statement_Opcode

.decl Statement_Next(statement: Statement, statementNext: Statement)
.input Statement_Next

.decl IsAlias(n:Alias)
      
IsAlias(0).

IsAlias(n+1) :-
  IsAlias(n),
  n+1 < MaxStackHeight.

.decl IsValue(v:Value)
.decl PushValue(stmt:Statement, v:Value)

IsValue(v),
PushValue(stmt, v) :-
  PUSH1(stmt,v);PUSH2(stmt,v);PUSH3(stmt,v);PUSH4(stmt,v);PUSH5(stmt,v);
  PUSH6(stmt,v);PUSH7(stmt,v);PUSH8(stmt,v);PUSH9(stmt,v);PUSH10(stmt,v);
  PUSH11(stmt,v);PUSH12(stmt,v);PUSH13(stmt,v);PUSH14(stmt,v);PUSH15(stmt,v);
  PUSH16(stmt,v);PUSH17(stmt,v);PUSH18(stmt,v);PUSH19(stmt,v);PUSH20(stmt,v);
  PUSH21(stmt,v);PUSH22(stmt,v);PUSH23(stmt,v);PUSH24(stmt,v);PUSH25(stmt,v);
  PUSH26(stmt,v);PUSH27(stmt,v);PUSH28(stmt,v);PUSH29(stmt,v);PUSH30(stmt,v);
  PUSH31(stmt,v);PUSH32(stmt,v).

IsValue(v) :-
  DynamicValue(v); AnyValue(v).

// Distinguished from all constant values
.decl DynamicValue(v:Value)
DynamicValue("Dynamic").
// Top of the lattice
.decl AnyValue(v:Value)
AnyValue("Any").

/*
 ***********
 * Define basic blocks
 ***********
 */
 
// Textbook material.
// A basic block starts:
//   - at a label
//   - after a jump.
// A basic block ends:
//   - at a jump
//   - before a label.
.decl IsBasicBlockHead(statement:Statement)
IsBasicBlockHead(statement) :-
  JUMPDEST(statement).
IsBasicBlockHead(statement) :-
  JUMPI(prevStatement),
//// REVIEW: check that this is equivalent
//  Statement_Opcode(prevStatement, opcode),
//  OpcodeAltersFlow(opcode),
  Statement_Next(prevStatement, statement).
IsBasicBlockHead(statement) :-
  Statement_Opcode(statement, _),
  !Statement_Next(_, statement).  

.decl IsBasicBlockTail(statement:Statement)
IsBasicBlockTail(statement) :-
  Statement_Opcode(statement, opcode),
  OpcodeAltersFlow(opcode).
IsBasicBlockTail(statement) :-
  JUMPDEST(labelstatement),
  Statement_Next(statement, labelstatement).

.output IsBasicBlockHead
.output IsBasicBlockTail

.decl Stmt_BasicBlock(statement:Statement, block:Block)
.decl Stmt_BasicBlockHead(statement:Statement, head:Statement)

Stmt_BasicBlockHead(stmt, stmt),
Stmt_BasicBlock(stmt, [stmt]) :-
  IsBasicBlockHead(stmt).

Stmt_BasicBlock(stmt, block) :-
  Stmt_BasicBlock(prevstmt, block),
  Statement_Next(prevstmt, stmt),
  !IsBasicBlockHead(stmt).

Stmt_BasicBlock(stmt, head) :-
  Stmt_BasicBlock(prevstmt, head),
  Statement_Next(prevstmt, stmt),
  !IsBasicBlockHead(stmt).


/*
 ***********
 * Key definitions
 ***********
 */
 
.type Context = [ block:Block ]

.decl BlockOutputContents(context:Context, block:Block, index:number, value:Value)
.decl BlockJumpTarget(context:Context, block:Block, value:Value)

// A summary of all the effects of the basic block up to a statement. The
// summary cannot contain only values, it will also refer symbolically to
// other locations (aliases) on the stack at the beginning of the basic block.
.decl LocalStackContents(stmt:Statement, index:number, value:ValueOrAlias)

.decl BeforeLocalStackContents(stmt:Statement, n:number, value:ValueOrAlias)

.decl BlockEdge(callerCtx:Context, caller:Block, calleeCtx:Context, callee:Block)
.decl ReachableContext(ctx:Context, block:Block)

// How many items the basic block will pop from the stack that existed at
// the beginning of its execution. I.e., how many items it will consume
// from its caller.
.decl BlockPopDelta(block:Block, delta:number)

// What is the difference in stack height effected by the basic block
.decl BlockStackDelta(block:Block, delta:number)

// Same for the effects up to a statement, since the beginning of the
// containing basic block.
.decl StatementPopDelta(statement:Statement, delta:number)
.decl StatementStackDelta(statement:Statement, delta:number)


/*
 ***********
 * Define block's behavior based on constituents
 ***********
 */

// Copy the stack values untouched by the callee basic block
BlockOutputContents(calleeCtx, callee, index+delta, value) :-
  BlockEdge(callerCtx, caller, calleeCtx, callee),
  BlockOutputContents(callerCtx, caller, index, value),
  index >= calleePopLen,
  index+delta <= MaxStackHeight,
  BlockPopDelta(callee, calleePopLen),
  BlockStackDelta(callee, delta).

// Handle the proper values pushed by this basic block
BlockOutputContents(ctx, block, index, value) :-
  LocalStackContents(stmt, index, valueOrAlias),
  IsBasicBlockTail(stmt),
  valueOrAlias = [alias, value], alias = alias,
  value != "invalid",
  Stmt_BasicBlock(stmt, block),
  ReachableContext(ctx, block).

// Handle the aliases pushed by this basic block
BlockOutputContents(calleeCtx, callee, index, realValue) :-
  LocalStackContents(stmt, index, valueOrAlias),
  IsBasicBlockTail(stmt),
  valueOrAlias = [alias, value],
  value = "invalid",
  Stmt_BasicBlock(stmt, callee),
  BlockEdge(callerCtx, caller, calleeCtx, callee),
  BlockOutputContents(callerCtx, caller, alias, realValue).

.output BlockOutputContents

// REVIEW: need to handle THROW. Maybe others?
BlockJumpTarget(ctx, block, value) :-
  BeforeLocalStackContents(stmt, 0, valueOrAlias),
  (JUMP(stmt); JUMPI(stmt)),
  valueOrAlias = [alias, value],
  value != "invalid",
  Stmt_BasicBlock(stmt, block),
  ReachableContext(ctx, block).

BlockJumpTarget(calleeCtx, callee, realValue) :-
  BeforeLocalStackContents(stmt, 0, valueOrAlias),
  (JUMP(stmt); JUMPI(stmt)),
  valueOrAlias = [alias, value],
  value = "invalid",
  Stmt_BasicBlock(stmt, block),
  BlockEdge(callerCtx, caller, calleeCtx, callee),
  BlockOutputContents(callerCtx, caller, alias, realValue).

.output BlockJumpTarget

/*
 ***********
 * Define semantics of instructions
 ***********
 */

.decl DynamicStatement(stmt:Statement)
DynamicStatement(stmt) :-
  ADDRESS(stmt); BALANCE(stmt); BLOCKHASH(stmt); CALLDATALOAD(stmt);
  CALLDATASIZE(stmt); CALLER(stmt); CALLVALUE(stmt); CODESIZE(stmt);
  COINBASE(stmt); DIFFICULTY(stmt); EXTCODESIZE(stmt); GAS(stmt);
  GASLIMIT(stmt); GASPRICE(stmt); NUMBER(stmt); ORIGIN(stmt);
  RETURNDATASIZE(stmt); TIMESTAMP(stmt).
// CALLDATACOPY and CODECOPY don't leave anything on the stack.
// GAS is not an environmental instruction, but it's still dynamic.
// RETURNDATASIZE is a new instruction, not in the Yellow Paper.
// Represents stack contents at previous location in the same block

// Constant values. Example of implementation of push1 to push32.
LocalStackContents(stmt, 0, [-1, value]) :-
  PushValue(stmt, value).

// Dynamic values.
LocalStackContents(stmt, 0, [-1, value]) :-
  DynamicStatement(stmt),
  DynamicValue(value).

// Values unaffected by this instruction.
// Pop is modeled as a side-effect!
LocalStackContents(stmt, n + delta, valueOrAlias) :-
  BeforeLocalStackContents(stmt, n, valueOrAlias),
  n >= numRemoved,
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, delta),
  OpcodePopWords(opcode, numRemoved).

// Arithmetic
LocalStackContents(stmt, 0, [ -1, anyvalue] ) :-
  AnyValue(anyvalue),
  Statement_Opcode(stmt, opcode),
  OpcodeIsArithmetic(opcode).

LocalStackContents(stmt, 0, [ -1, dynamicvalue] ) :-
  DynamicValue(dynamicvalue),
  Statement_Opcode(stmt, opcode),
  OpcodeIsArithmetic(opcode),
  (BeforeLocalStackContents(stmt, 0, [alias, dynamicvalue]);
   BeforeLocalStackContents(stmt, 1, [alias, dynamicvalue])).

// Dup
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP1(stmt), BeforeLocalStackContents(stmt, 0, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP2(stmt), BeforeLocalStackContents(stmt, 1, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP3(stmt), BeforeLocalStackContents(stmt, 2, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP4(stmt), BeforeLocalStackContents(stmt, 3, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP5(stmt), BeforeLocalStackContents(stmt, 4, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP6(stmt), BeforeLocalStackContents(stmt, 5, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP7(stmt), BeforeLocalStackContents(stmt, 6, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP8(stmt), BeforeLocalStackContents(stmt, 7, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP9(stmt), BeforeLocalStackContents(stmt, 8, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP10(stmt), BeforeLocalStackContents(stmt, 9, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP11(stmt), BeforeLocalStackContents(stmt, 10, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP12(stmt), BeforeLocalStackContents(stmt, 11, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP13(stmt), BeforeLocalStackContents(stmt, 12, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP14(stmt), BeforeLocalStackContents(stmt, 13, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP15(stmt), BeforeLocalStackContents(stmt, 14, valueOrAlias).
LocalStackContents(stmt, 0, valueOrAlias) :-
  DUP16(stmt), BeforeLocalStackContents(stmt, 15, valueOrAlias).

.output LocalStackContents

/*
 ***********
 * CFG edges and reachable contexts
 ***********
 */
.output BlockEdge

ReachableContext(calleeCtx, callee) :-
  BlockEdge(_, _, calleeCtx, callee).
  
.decl OriginalBlock(block:Block)
OriginalBlock([stmt]) :-
  IsBasicBlockHead(stmt),
  !Statement_Next(_, stmt).

ReachableContext( [["Dummy"]], block) :-
  OriginalBlock(block).

BlockEdge(callerCtx, caller, ?mergeContextMacro, [fallthrough]) :-
  JUMPI(jumpStmt),
  Stmt_BasicBlock(jumpStmt, caller),
  ReachableContext(callerCtx, caller),
  Statement_Next(jumpStmt, fallthrough),
  ?mergeContextMacro = [caller].

BlockEdge(callerCtx, caller, ?mergeContextMacro, [callee]) :-
  (JUMP(jumpStmt); JUMPI(jumpStmt)),
  Stmt_BasicBlock(jumpStmt, caller),
  BlockJumpTarget(callerCtx, caller, value),
  IsBasicBlockHead(callee),
  ord(callee) = ord(value),
  ?mergeContextMacro = [caller].


/*
 ***********
 * Auxiliary relations: BeforeLocalStackContents
 ***********
 */

// General case
BeforeLocalStackContents(stmt, n, value) :-
  Statement_Next(prevStmt, stmt),
  !IsBasicBlockTail(prevStmt),
  LocalStackContents(prevStmt, n, value).

// Special case for block head (contains only aliases). Initialize all
// stack positions, from zero to max consumed (from the caller's stack) by
// the basic block. They are initialized to symbolic aliases.
BeforeLocalStackContents(stmt, alias, [alias, "invalid"]) :-
  IsBasicBlockHead(stmt),
  Stmt_BasicBlock(stmt, block),
  BlockPopDelta(block, delta),
  IsAlias(alias),
  alias < delta.


/*
 ***********
 * Auxiliary relations: block/statement pop deltas and total stack effects
 ***********
 */

StatementStackDelta(stmt, delta) :-
  IsBasicBlockHead(stmt),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, delta).
StatementStackDelta(stmt, prevdelta + newdelta) :-
  StatementStackDelta(prevstmt, prevdelta),
  !IsBasicBlockTail(prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, newdelta).

// Need to keep a running maximum of elements consumed from the stack
// as it was at the beginning of the basic block.
StatementPopDelta(stmt, delta) :-
  IsBasicBlockHead(stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, delta).
StatementPopDelta(stmt, popdelta - prevStackDelta) :-
  StatementStackDelta(prevstmt, prevStackDelta),
  StatementPopDelta(prevstmt, prevPopDelta),
  !IsBasicBlockTail(prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, popdelta),
  popdelta - prevStackDelta > prevPopDelta.
StatementPopDelta(stmt, prevPopDelta) :-
  StatementStackDelta(prevstmt, prevStackDelta),
  StatementPopDelta(prevstmt, prevPopDelta),
  !IsBasicBlockTail(prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, popdelta),
  popdelta - prevStackDelta <= prevPopDelta.

BlockStackDelta(block, delta) :-
  IsBasicBlockTail(stmt),
  StatementStackDelta(stmt, delta),
  Stmt_BasicBlock(stmt, block).

BlockPopDelta(block, delta) :-
  IsBasicBlockTail(stmt),
  StatementPopDelta(stmt, delta),
  Stmt_BasicBlock(stmt, block).


