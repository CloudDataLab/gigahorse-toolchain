#define MAX_STACK_HEIGHT 100
#define CheckIsVariable(v) ((v) < 0)
#define CheckIsAlias(v) ((v) >= 0, (v) < MAX_STACK_HEIGHT)

#include "decompiler_instructions.dl"
#include "decompiler_statistics.dl"
#include "functions.dl"


.type Block = [ head:Statement ]
.type Value = symbol
.number_type Variable
.number_type Alias

// We want a sum, but sum types crash, so we use a product
.type VariableOrAlias = Variable | Alias

.decl Variable_Value(variable: Variable, value: Value)

.decl IsVariable(n:Variable)

// One to one mapping
.decl Statement_Defines(statement: Statement, variable: Variable)

.decl _StatementNum(statement: Statement, num: number)

_StatementNum("0x0", -1).

_StatementNum(next, n-1) :-
  _StatementNum(stmt, n),
  Statement_Next(stmt, next).

// We pre-assign variables to every statement except if they are
// not really creating new values on the stack (e.g. no pushes or simple swaps)
IsVariable(n),
Statement_Defines(stmt, n) :-
 _StatementNum(stmt, n),
 Statement_Opcode(stmt, opcode),
 OpcodePushWords(opcode, m), m > 0,
 !TACNOP(stmt).

.decl IsAlias(n:Alias)
      
IsAlias(0).

IsAlias(n+1) :-
  IsAlias(n),
  n+1 < MAX_STACK_HEIGHT.

.decl IsAliasLessThan(n:Alias, maximum:number)

IsAliasLessThan(n, maximum) :-
  IsAlias(n),
  IsAlias(maximum),
  n < maximum.
 
.decl IsValue(v:Value)
.decl ConcreteValue(v:Value)

IsValue(v) :-
  DynamicValue(v); AnyValue(v).

ConcreteValue(v) :- IsValue(v), !DynamicValue(v), !AnyValue(v).
               
// Distinguished from all constant values
.decl DynamicValue(v:Value)
DynamicValue("Dynamic").
// Top of the lattice
.decl AnyValue(v:Value)
AnyValue("Any").

/*
 ***********
 * Define basic blocks
 ***********
 */
 
// Textbook material.
// A basic block starts:
//   - at a label
//   - after a jump.
// A basic block ends:
//   - at a jump
//   - before a label.
.decl IsBasicBlockHead(statement:Statement)
IsBasicBlockHead(statement) :-
  JUMPDEST(statement).
IsBasicBlockHead(statement) :-
  JUMPI(prevStatement),
//// REVIEW: check that this is equivalent
//  Statement_Opcode(prevStatement, opcode),
//  OpcodeAltersFlow(opcode),
  Statement_Next(prevStatement, statement).
IsBasicBlockHead(statement) :-
  Statement_Opcode(statement, _),
  !Statement_Next(_, statement).  

.decl IsBasicBlockTail(statement:Statement)
IsBasicBlockTail(statement) :-
  Statement_Opcode(statement, opcode),
  OpcodeAltersFlow(opcode).

IsBasicBlockTail(statement) :-
  Statement_Next(statement, labelstatement),
  JUMPDEST(labelstatement).

.decl Stmt_BasicBlock(statement:Statement, block:Block)
.decl Stmt_BasicBlockHead(statement:Statement, head:Statement)

Stmt_BasicBlockHead(stmt, stmt),
Stmt_BasicBlock(stmt, [stmt]) :-
  IsBasicBlockHead(stmt).

Stmt_BasicBlockHead(stmt, blockHead),
Stmt_BasicBlock(stmt, block) :-
  Stmt_BasicBlock(prevstmt, block),
  Statement_Next(prevstmt, stmt),
  !IsBasicBlockHead(stmt),
  block = [blockHead].

Stmt_BasicBlock(stmt, head) :-
  Stmt_BasicBlock(prevstmt, head),
  Statement_Next(prevstmt, stmt),
  !IsBasicBlockHead(stmt).

.decl BasicBlock_Tail(block:Block, tail:Statement)

BasicBlock_Tail(block, tail) :-
  Stmt_BasicBlock(tail, block),
  IsBasicBlockTail(tail).


/*
 ***********
 * Key definitions
 ***********
 */
 
.type Context = [ block:Block ]

.decl BlockOutputContents(context:Context, block:Block, index:number, var:Variable)
.decl BlockInputContents(context:Context, block:Block, index:number, var:Variable)
.decl BlockJumpTarget(context:Context, block:Block, var:Variable)

// A summary of all the effects of the basic block up to a statement. The
// summary cannot contain only values, it will also refer symbolically to
// other locations (aliases) on the stack at the beginning of the basic block.
.decl LocalStackContents(stmt:Statement, index:number, value:VariableOrAlias)

.decl BeforeLocalStackContents(stmt:Statement, n:number, value:VariableOrAlias)

.decl BlockEdge(callerCtx:Context, caller:Block, calleeCtx:Context, callee:Block)
.decl ReachableContext(ctx:Context, block:Block)

// How many items the basic block will pop from the stack that existed at
// the beginning of its execution. I.e., how many items it will consume
// from its caller.
.decl BlockPopDelta(block:Block, delta:number)

// What is the difference in stack height effected by the basic block
.decl BlockStackDelta(block:Block, delta:number)

// Same for the effects up to a statement, since the beginning of the
// containing basic block.
.decl StatementPopDelta(statement:Statement, delta:number)
.decl StatementStackDelta(statement:Statement, delta:number)


/*
 ***********
 * Define block's behavior based on constituents
 ***********
 */

BlockInputContents(calleeCtx, callee, index, value) :-
  BlockOutputContents(callerCtx, caller, index, value),
  BlockEdge(callerCtx, caller, calleeCtx, callee).
  .plan 1:(2,1)
      
// Copy the stack values untouched by the callee basic block
BlockOutputContents(calleeCtx, callee, index+delta, value) :-
  BlockInputContents(calleeCtx, callee, index, value),
  index >= calleePopLen,
  index+delta <= MAX_STACK_HEIGHT,
  BlockPopDelta(callee, calleePopLen),
  BlockStackDelta(callee, delta).

// Handle the proper values pushed by this basic block
BlockOutputContents(ctx, block, index, varOrAlias) :-
  ReachableContext(ctx, block),
  BasicBlock_Tail(block, stmt),
  LocalStackContents(stmt, index, varOrAlias),
  CheckIsVariable(varOrAlias).

// Handle the aliases pushed by this basic block
BlockOutputContents(ctx, block, index, realValue) :-
  BlockInputContents(ctx, block, varOrAlias, realValue),
  BasicBlock_Tail(block, stmt),
  LocalStackContents(stmt, index, varOrAlias),
  CheckIsAlias(varOrAlias).


// REVIEW: need to handle THROW. Maybe others?
BlockJumpTarget(ctx, block, varOrAlias) :-
  ReachableContext(ctx, block),
  Stmt_BasicBlock(stmt, block),
  IsJump(stmt),
  BeforeLocalStackContents(stmt, 0, varOrAlias),
  CheckIsVariable(varOrAlias).

BlockJumpTarget(calleeCtx, callee, realVariable) :-
  BlockInputContents(calleeCtx, callee, varOrAlias, realVariable),
  Stmt_BasicBlock(stmt, callee),
  IsJump(stmt),
  BeforeLocalStackContents(stmt, 0, varOrAlias),
  CheckIsAlias(varOrAlias).

.decl BlockJumpValidTarget(ctx:Context, block:Block, variable: Variable, target:Block)

BlockJumpValidTarget(ctx, block, variable, [target]) :-
  BlockJumpTarget(ctx, block, variable),
  Variable_Value(variable, value),
  ConcreteValue(value),
  ord(value) = ord(target),
  JUMPDEST(target).
/*
 ***********
 * Define semantics of instructions
 ***********
 */
// Values unaffected by this instruction.
// Pop is modeled as a side-effect!
LocalStackContents(stmt, n + delta, varOrAlias) :-
  BeforeLocalStackContents(stmt, n, varOrAlias),
  n >= numRemoved,
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, delta),
  OpcodePopWords(opcode, numRemoved).

// Base case, handles most cases
LocalStackContents(stmt, 0, var) :-
  Statement_Defines(stmt, var),
  !TACNOP(stmt).

// Constant values. Example of implementation of push1 to push32.
Variable_Value(var, value) :-
  PushValue(stmt, value),
  Statement_Defines(stmt, var).

// error cases for dynamic instructions
Variable_Value(var, "0x0") :-
  (CREATE(stmt) ; CALL(stmt) ; CALLCODE(stmt) ; STATICCALL(stmt)),
  Statement_Defines(stmt, var).

// Dynamic values.
Variable_Value(var, value) :-
  DynamicStatement(stmt),
  Statement_Defines(stmt, var),
  DynamicValue(value).

// Get current program counter
Variable_Value(var, value) :-
  PC(stmt),
  IsValue(value), ord(value) = ord(stmt),
  Statement_Defines(stmt, var).

.decl ArithmeticOpcodes(stmt:Statement, var0:VariableOrAlias, var1:VariableOrAlias, res:Variable)

ArithmeticOpcodes(stmt, var0, var1, res) :-
  Statement_Opcode(stmt, opcode),
  OpcodeIsArithmetic(opcode),
  BeforeLocalStackContents(stmt, 0, var0),
  BeforeLocalStackContents(stmt, 1, var1),
  Statement_Defines(stmt, res).

Variable_Value(resVar, val1) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  Statement_Opcode(stmt, opcode),
  Variable_Value(var0, val0),
  Variable_Value(var1, val1),
  OperationIsEq(opcode, val0).

Variable_Value(resVar, val0) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  Statement_Opcode(stmt, opcode),
  Variable_Value(var0, val0),
  Variable_Value(var1, val1),
  OperationIsEq(opcode, val1).

Variable_Value(resVar, res) :-
  ArithmeticOpcodes(stmt, var0, var1, resVar),
  Statement_Opcode(stmt, opcode),
  Variable_Value(var0, val0),
  Variable_Value(var1, val1),
  (OperationIs(opcode, val0, res) ; OperationIs(opcode, val1, res)).

// Arithmetic
Variable_Value(var, anyvalue) :-
  AnyValue(anyvalue),
  Statement_Opcode(stmt, opcode),
  OpcodeIsArithmetic(opcode),
  Statement_Defines(stmt, var).

Variable_Value(var, dynamicvalue) :-
  DynamicValue(dynamicvalue),
  Statement_Opcode(stmt, opcode),
  OpcodeIsArithmetic(opcode),
  (BeforeLocalStackContents(stmt, 0, dynamicvar);
   BeforeLocalStackContents(stmt, 1, dynamicvar)),
  Variable_Value(dynamicvar, dynamicvalue),
  Statement_Defines(stmt, var).


// DUP


LocalStackContents(stmt, 0, duplicated) :-
  Statement_Opcode(stmt, opcode),
  DUPN(opcode, n),
  BeforeLocalStackContents(stmt, n, duplicated).

LocalStackContents(stmt, m+1, other) :-
  Statement_Opcode(stmt, opcode),
  DUPN(opcode, n),
  IsAliasLessThan(m, n+1),
  BeforeLocalStackContents(stmt, m, other).

// SWAP
LocalStackContents(stmt, n, value0),
LocalStackContents(stmt, 0, valueN) :-
  Statement_Opcode(stmt, opcode),
  SWAPN(opcode, n),
  BeforeLocalStackContents(stmt, n, valueN),
  BeforeLocalStackContents(stmt, 0, value0).

LocalStackContents(stmt, m, other) :-
  Statement_Opcode(stmt, opcode),
  SWAPN(opcode, n),
  IsAliasLessThan(m, n), m > 0,
  BeforeLocalStackContents(stmt, m, other).

// MLOAD
Variable_Value(var, dynamicvalue) :-
  DynamicValue(dynamicvalue),
  MLOAD(stmt),
  Statement_Defines(stmt, var).

// SLOAD
Variable_Value(var, dynamicvalue) :-
  DynamicValue(dynamicvalue),
  SLOAD(stmt),
  Statement_Defines(stmt, var).

/*
 ***********
 * CFG edges and reachable contexts
 ***********
 */

ReachableContext(calleeCtx, callee) :-
  BlockEdge(_, _, calleeCtx, callee).
  
.decl OriginalBlock(block:Block)
OriginalBlock([stmt]) :-
  IsBasicBlockHead(stmt),
  !Statement_Next(_, stmt).

ReachableContext( [["<Initial Context>"]], block) :-
  OriginalBlock(block).

.decl FallThroughStmt(stmt:Statement)

FallThroughStmt(stmt) :-
  IsBasicBlockTail(stmt),
  !JUMP(stmt),
  Statement_Opcode(stmt, opcode),
  !OpcodePossiblyHalts(opcode).   

BlockEdge(callerCtx, caller, ?mergeContextMacro, [fallthrough]) :-
  ReachableContext(callerCtx, caller),
  FallThroughStmt(stmt),
  Stmt_BasicBlock(stmt, caller),
  Statement_Next(stmt, fallthrough),
  IsBasicBlockHead(fallthrough),
  ?mergeContextMacro = [caller].

BlockEdge(callerCtx, caller, ?mergeContextMacro, callee) :-
  BlockJumpValidTarget(callerCtx, caller, _, callee),
  ?mergeContextMacro = [caller].


/*
 ***********
 * Auxiliary relations: BeforeLocalStackContents
 ***********
 */

// General case
BeforeLocalStackContents(stmt, n, value) :-
  Statement_Next(prevStmt, stmt),
  !IsBasicBlockTail(prevStmt),
  LocalStackContents(prevStmt, n, value).

// Special case for block head (contains only aliases). Initialize all
// stack positions, from zero to max consumed (from the caller's stack) by
// the basic block. They are initialized to symbolic aliases.
BeforeLocalStackContents(stmt, alias, alias) :-
  IsBasicBlockHead(stmt),
  Stmt_BasicBlock(stmt, block),
  BlockPopDelta(block, delta),
  IsAliasLessThan(alias, delta).


/*
 ***********
 * Auxiliary relations: block/statement pop deltas and total stack effects
 ***********
 */

StatementStackDelta(stmt, delta) :-
  IsBasicBlockHead(stmt),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, delta).

StatementStackDelta(stmt, prevdelta + newdelta) :-
  StatementStackDelta(prevstmt, prevdelta),
  !IsBasicBlockTail(prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodeStackDelta(opcode, newdelta).

// Need to keep a running maximum of elements consumed from the stack
// as it was at the beginning of the basic block.
StatementPopDelta(stmt, delta) :-
  IsBasicBlockHead(stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, delta).

StatementPopDelta(stmt, popdelta - prevStackDelta) :-
  StatementStackDelta(prevstmt, prevStackDelta),
  StatementPopDelta(prevstmt, prevPopDelta),
  !IsBasicBlockTail(prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, popdelta),
  popdelta - prevStackDelta > prevPopDelta.

StatementPopDelta(stmt, prevPopDelta) :-
  StatementStackDelta(prevstmt, prevStackDelta),
  StatementPopDelta(prevstmt, prevPopDelta),
  !IsBasicBlockTail(prevstmt),
  Statement_Next(prevstmt, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, popdelta),
  popdelta - prevStackDelta <= prevPopDelta.

BlockStackDelta(block, delta) :-
  BasicBlock_Tail(block, stmt),
  StatementStackDelta(stmt, delta).

BlockPopDelta(block, delta) :-
  BasicBlock_Tail(block, stmt),
  StatementPopDelta(stmt, delta).
