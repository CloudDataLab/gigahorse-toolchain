/*****
 * Function discovery logic
 *****/

/******
  * First, heuristics for discovering public functions
******/
// Special entry point to public function found heuristically
.decl PublicFunctionEntry(basicBlock: Block, sigHash: Value)
// Code inserted by compiler to dispatch to the correct public function
.decl PublicFunctionDispatcher(basicBlock: Block, sigHash: Value)
// (Possibly) Code inserted by compiler to compare function signature
.decl BlockComparesSig(block: Block, sigHash: Value)

// Compares label from stack to a constant: common public function dispatch
// pattern
BlockComparesSig(block, sigHash) :-
  Statement_Block(pushStmt, block),
  PUSH4(pushStmt, sigHash),
  Statement_Defines(pushStmt, sigHashVar),
  Statement_Block(eqStmt, block),
  EQ(eqStmt),
  Statement_Uses(eqStmt, sigHashVar, _),
  Statement_Block(jumpiStmt, block),
  JUMPI(jumpiStmt),
  Statement_Defines(eqStmt, pred),
  Statement_Uses(jumpiStmt, pred, 1).

// Initial case, uses CALLDATALOAD
PublicFunctionDispatcher(block, sigHash) :-
  Statement_Block(stmt, block),
  CALLDATALOAD(stmt),
  BlockComparesSig(block, sigHash).

// General case
PublicFunctionDispatcher(block, sigHash) :-
  BlockComparesSig(block, sigHash),
  BlockEdge(_, prev, _, block),
  PublicFunctionDispatcher(prev, _).

PublicFunctionEntry([stmt], sigHash) :-
  PublicFunctionDispatcher(block, sigHash),
  Statement_Block(jumpiStmt, block),
  JUMPI(jumpiStmt),
  BeforeLocalStackContents(jumpiStmt, _, labelvar),
  Variable_Value(labelvar, label),
  IsBasicBlockHead(stmt),
  ord(label) = ord(stmt).


/******
         Generic basic block Reachable-from implementation
******/

.decl ReachableFrom(block:Block, from:Block)

ReachableFrom(block, block) :- Statement_Block(_, block).

ReachableFrom(blockNext, blockPrev) :-
  ReachableFrom(block, blockPrev),
  BlockEdge(_, block, _, blockNext). 


/******
         Heuristics for detecting call-return patterns
******/

.decl PossibleReturnAddress(caller:Block, ret:Block, target:Block)

// Possibly a return:
// a) basic block jumps to a valid "non-locally-derived" address
// b) address originates at a caller that can reach the
//    returning basic block.
PossibleReturnAddress(callerBlock, retBlock, target) :-
  BlockJumpValidTarget(_, retBlock, targetVariable, target),
  BasicBlock_Tail(callerBlock, callerStmt),
  callerBlock != retBlock,
  IsJump(callerStmt),
  Statement_Defines(otherCallerStatement, targetVariable),
  Statement_Block(otherCallerStatement, callerBlock).


.decl PossibleFunctionCall(caller:Block, func:Block, retBlock:Block, retTarget:Block)

PossibleFunctionCall(caller, func, retBlock, retTarget) :-
  PossibleReturnAddress(caller, retBlock, retTarget),
  BlockJumpValidTarget(_, caller, _, func).

.decl PossiblyInFunction(block:Block, func:Block)

// Which basic blocks belong to which function
PossiblyInFunction(func, func) :-
  PossibleFunctionCall(_, func, _, _).

// In this case we're moving onto another function
PossiblyInFunction(next, func) :-
  PossiblyInFunction(block, func),
  BlockEdge(_, block, _, next),
  !PossibleFunctionCall(block, _, _, _).

// In this case we're return from a function we've just called
PossiblyInFunction(retTarget, func) :-
  PossiblyInFunction(block, func),
  PossibleFunctionCall(block, _, _, retTarget).

// What is a function?
// A function has to have a single entry point

.decl NotRegularFunction(func:Block)

// A basic block can only belong to a single function
// Solution: Pick one!
NotRegularFunction([func2]) :-
  PossiblyInFunction(block, [func1]),
  PossiblyInFunction(block, [func2]),
  ord(func1) > ord(func2).

// A function can only be entered by calling it
NotRegularFunction(func) :-
  PossiblyInFunction(_, func),
  BlockEdge(_, caller, _, func),
  !PossibleFunctionCall(caller, func, _, _).


// caller calls func and func returns to retTarget
.decl FunctionCallReturn(caller:Block, func:Block, retTarget:Block)
.decl Function_Return(func:Block, retBlock:Block)

Function_Return(func, retBlock),
FunctionCallReturn(caller, func, retTarget) :-
  PossibleFunctionCall(caller, func, retBlock, retTarget),
  !NotRegularFunction(func).


// Further function decomposition.
// Detects function boundaries, calls and returns iteratively.  Main
// heuristic: if a block is reachable by two others that have to be in
// different functions, then that block is also in an independent
// function.

// Used components to force stratification.
.comp FunctionDetection {
  // An Entry to a function (private or public)
  .decl FunctionEntry(block: Block)
  // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionEntry(block: Block)

  // Basic block belongs to function
  .decl InFunction(block: Block, function: Block)
  // Basic block performs a function call 
  .decl FunctionCall(block: Block, func: Block)
   // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionCall(block: Block, func: Block)

  InFunction(block, block) :-
    PrevFunctionEntry(block).

  InFunction(next, func) :-
    InFunction(block, func),
    BlockEdge(_, block, _, next),
    !PrevFunctionCall(block, next),
    !Function_Return(_, block).

 InFunction(next, func) :-
   InFunction(block, func),
   FunctionCallReturn(block, _, next).

  // Heuristic for finding function calls
  // Execution flows to a basic block that is
  // part of more than one function, TODO
  FunctionCall(prev, block),
  FunctionEntry(block) :-
    InFunction(block, func1),
    InFunction(block, func2),
    func1 != func2,
    BlockEdge(_, prev, _, block),
    !Function_Return(_, prev),
    !(InFunction(prev, func1), InFunction(prev, func2)).

  FunctionCall(prev, func1) :- PrevFunctionCall(prev, func1).
}

// Initialize and iterate the algorithm
.init detector0 = FunctionDetection
detector0.PrevFunctionEntry(block) :-
  PublicFunctionEntry(block, _).
detector0.PrevFunctionEntry(block) :-
  FunctionCallReturn(_, block, _).

detector0.PrevFunctionCall(prev, func) :-
  PublicFunctionEntry(func, sigHash),
  PublicFunctionDispatcher(prev, sigHash).

detector0.PrevFunctionCall(prev, func) :-
  FunctionCallReturn(prev, func, _).
  
.init detector1 = FunctionDetection
detector1.PrevFunctionEntry(block) :- detector0.FunctionEntry(block).
detector1.PrevFunctionCall(block, func) :- detector0.FunctionCall(block, func).

.init detector2 = FunctionDetection
detector2.PrevFunctionEntry(block) :- detector1.FunctionEntry(block).
detector2.PrevFunctionCall(block, func) :- detector1.FunctionCall(block, func).

/***********
   Collecting all function decomposition results
***********/

// block ends with a call to func
.decl FunctionCall(block:Block, func:Block)

// Case 1: private call return
FunctionCall(block, func) :- FunctionCallReturn(block, func, _).

// Case 2: dispatch public functions
FunctionCall(block, func) :-
  PublicFunctionEntry(func, sigHash),
  PublicFunctionDispatcher(block, sigHash).

// Case 3: further decomposition using components
FunctionCall(block, func) :-
  detector0.FunctionCall(block, func) ;
  detector1.FunctionCall(block, func) ;
  detector2.FunctionCall(block, func).

.decl Function(func:Block)

// Case 1: Smart contract entry
Function(["0x0"]).

// Remaining cases handled by inputs/outputs of componenets
Function(func) :-
  detector0.PrevFunctionEntry(func) ;
  detector0.FunctionEntry(func) ;
  detector1.FunctionEntry(func) ;
  detector2.FunctionEntry(func).


/***********
 * Discovery of arguments accepted by a function   
 ***********/

// Intra-function edges (i.e., real CFG edges)
.decl LocalBlockEdge(block: Block, next: Block)

LocalBlockEdge(block, next) :-
  BlockEdge(_, block, _, next),
  !Function(next),
  !Function_Return(_, block).

// REVIEW: basic blocks are interrupted at function call instructions
// (unlike, say, LLVM IR) but we connect the block to the one after
// the function return.
LocalBlockEdge(block, next) :-
  BlockEdge(_, block, _, func),
  FunctionCallReturn(block, func, next).

// New Instructions
// CALLPRIVATE(stmt, function)
// CALLPRIVATEI(stmt, cond, function)
// RETURNPRIVATE(stmt)
// RETURNPRIVATEI(stmt, cond)

.decl InFunction(block: Block, func: Block)
 
InFunction(block, block) :-
  Function(block).

InFunction(next, func) :-
  InFunction(block, func),
  BlockEdge(_, block, _, next),
  !FunctionCall(block, next),
  !Function_Return(_, block).

InFunction(next, func) :-
  InFunction(block, func),
  FunctionCallReturn(block, _, next).

.decl Function_ReachableBlocks(func: Block, block: Block)

Function_ReachableBlocks(func, block) :-
   InFunction(block, func).

Function_ReachableBlocks(func, other) :-
  Function_ReachableBlocks(func, block),
  FunctionCall(block, callee),
  Function_ReachableBlocks(callee, other).

.decl Function_Uses(func: Block, var: Variable)

Function_Uses(func, var) :-
   Function_ReachableBlocks(func, block),
   Statement_Block(stmt, block),
   Statement_Uses(stmt, var, _).

.decl Function_Defines(func: Block, var: Variable)

Function_Defines(func, var) :-
   Function_ReachableBlocks(func, block),
   Statement_Block(stmt, block),
   Statement_Defines(stmt, var).


.decl NumberOfFunctionArguments(func: Block, num: StackIndex)
/*
// 
// NEW VERSION, WIP
//

.decl NumberOfFunctionArgumentsIsAtLeast(func: Block, num: StackIndex)
.decl NumberOfFunctionReturns(func: Block, num: StackIndex)
.decl NumberOfFunctionReturnsIsAtMost(func: Block, num: StackIndex)

NumberOfFunctionReturnsIsAtMost(func, 10),
NumberOfFunctionArgumentsIsAtLeast(func, 0) :-
   Function(func).

NumberOfFunctionArgumentsIsAtLeast(func, num) :-
   num = blah + argCallee - retCallee,
   NumberOfFunctionArgumentsIsAtLeast(callee, argCallee),
   NumberOfFunctionReturnsIsAtMost(callee, retCallee),
   CallEdge(func, callee).

// In our current state, basic blocks may be ending in a function call
// or return (implicitly "enhanced" blocks). Compute the useful
// concepts from the decompiler, while also taking into account the
// call.
.decl EnhancedBlockPopDeltaIsAtLeast(block:Block, delta:number)

// the block doesn't end in a call or a return
EnhancedBlockPopDeltaIsAtLeast(block, delta) :-
   !FunctionCall(block, _),
   BlockPopDelta(block, delta).

EnhancedBlockPopDeltaIsAtLeast(block, delta + argsConsumed - retsProduced) :-
   FunctionCall(block, func),
   BlockPopDelta(block, delta),
   NumberOfFunctionArgumentsIsAtLeast(func, argsConsumed),
   NumberOfFunctionReturnsIsAtMost(func, retsProduced).

// END NEW VERSION
*/

//
// OLD VERSION, but works
//

// This is used to calculate an upper bound of the number of arguments
// for a function. A more accurate number of arguments is calculated based
// on the FunctionalBlock*Contents information
.decl ImpossibleFunctionArguments(func: Block, stackIndex: StackIndex)

ImpossibleFunctionArguments(func, stackIndex) :-
   Function(func),
   BlockInputContents(_, func, stackIndex, var),
   !Function_Uses(func, var).

ImpossibleFunctionArguments(func, n+1) :-
   Function(func),
   n = max stackIndex: BlockInputContents(_, func, stackIndex, _).

NumberOfFunctionArguments(func, n) :-
   n = min stackIndex: ImpossibleFunctionArguments(func, stackIndex),
   Function(func).

// END OLD VERSION


NumberOfFunctionArguments(["0x0"], 0).

//TODO
.decl Variable_String(var:Variable, var_rep:symbol)
.decl FunctionCallStmt(stmt: Statement)

FunctionCallStmt(stmt) :-
   FunctionCall(block, _),
   BasicBlock_Tail(block, stmt).
   
.decl FunctionReturnStmt(stmt: Statement)

FunctionReturnStmt(stmt) :-
   Function_Return(_, block),
   BasicBlock_Tail(block, stmt).
   
.decl FunctionArgument(func: Block, n: StackIndex, var: Variable)
.decl FunctionCallReturnArgument(func: Block, n: StackIndex, var: Variable)

.decl FunctionalStatement_Uses_Local(stmt:Statement, var:VariableOrStackIndex, n:StackIndex)

.decl FunctionalStatement_Uses(stmt:Statement, var:Variable, n:StackIndex)

Variable_String(var, var_rep) :-
   Statement_Defines(var_rep, var).

Variable_String(var, cat("arg",n_str)),
FunctionArgument([funcStmt], n, var) :-
  NumberOfFunctionArguments([funcStmt], n_args),
  IsStackIndexLessThan(n, n_args),
  FRESH_VARIABLE(var, funcStmt, n),
  StackIndexToString(n, n_str).

Variable_String(newVar, cat(callStmt, cat("_", n_str))),
FunctionalStatement_Defines(callStmt, newVar, n),
FunctionCallReturnArgument(caller, n, newVar) :-
  FunctionCall(caller, func),
  NumberOfFunctionReturnArguments(func, n_arg),
  IsStackIndexLessThan(n, n_arg),
  BasicBlock_Tail(caller, callStmt),
  FRESH_VARIABLE(newVar, callStmt, n),
  StackIndexToString(n, n_str).

// This is used to calculate an upper bound of the number of variables
// a function may return.
.decl ImpossibleFunctionReturnArguments(func: Block, stackIndex: StackIndex)

ImpossibleFunctionReturnArguments(func, stackIndex) :-
   BlockOutputContents(_, func, stackIndex, var),
   !Function_Uses(func, var),
   !Function_Defines(func, var).

ImpossibleFunctionReturnArguments(func, n+1) :-
   Function(func),
   n = max stackIndex: BlockOutputContents(_, func, stackIndex, _).

.decl NumberOfFunctionReturnArguments(func: Block, num: StackIndex)

NumberOfFunctionReturnArguments(func, n) :-
   n = min stackIndex: ImpossibleFunctionReturnArguments(func, stackIndex),
   Function(func).

// Renaming variables in functions
.decl FunctionalBlockInputContents(block:Block, index:number, var:Variable)
.decl FunctionalBlockOutputContents(block:Block, index:number, var:Variable)

FunctionalBlockInputContents(func, n, var) :-
   FunctionArgument(func, n, var).

FunctionalBlockInputContents(nextBlock, index, variable) :-
  FunctionalBlockOutputContents(block, index, variable),
  LocalBlockEdge(block, nextBlock).

// TODO: There are three cases
// 1) Normal block to block flow, i.e. no function calls from block to block
FunctionalBlockOutputContents(caller, index, variable) :-
  BeforeFunctionCallFunctionalBlockOutputContents(caller, index, variable),
  !FunctionCall(caller, _).

// 2) First block calls a function, take return args from function call
.decl FunctionalStatement_Defines(callStmt:Statement, newVar:Variable, n: number)

FunctionalBlockOutputContents(caller, n, newVar) :-
  FunctionCallReturnArgument(caller, n, newVar).

// 3) First block calls a function, take any remaining variables that have
//    not been passed as arguments, and shift
FunctionalBlockOutputContents(caller, newIndex, variable) :-
  FunctionCall(caller, func),
  NumberOfFunctionReturnArguments(func, n_out),
  NumberOfFunctionArguments(func, n_in),
  BeforeFunctionCallFunctionalBlockOutputContents(caller, index, variable),
  index >= n_in,
  newIndex = index+n_out-n_in,
  newIndex >= 0.

.decl BeforeFunctionCallFunctionalBlockOutputContents(caller: Block, index: StackIndex, variable: Variable)

// Copy the stack variables untouched by the callee basic block
BeforeFunctionCallFunctionalBlockOutputContents(callee, index+delta, variable) :-
  FunctionalBlockInputContents(callee, index, variable),
  index >= calleePopLen,
  index+delta <= MAX_STACK_HEIGHT,
  BlockPopDelta(callee, calleePopLen),
  BlockStackDelta(callee, delta).

// Handle the proper variables pushed by this basic block
BeforeFunctionCallFunctionalBlockOutputContents(block, index, var) :-
  InFunction(block, _),
  BasicBlock_Tail(block, stmt),
  LocalStackContents(stmt, index, var),
  CheckIsVariable(var).

// Handle the stackIndexes pushed by this basic block
BeforeFunctionCallFunctionalBlockOutputContents(block, index, realVariable) :-
  FunctionalBlockInputContents(block, stackIndex, realVariable),
  BasicBlock_Tail(block, stmt),
  LocalStackContents(stmt, index, stackIndex),
  CheckIsStackIndex(stackIndex).

// TODO, add defines for function call return args

// TODO, check case for function call
FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
  FunctionCall(block, func),
  NumberOfFunctionArguments(func, n_in),
  BasicBlock_Tail(block, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, m),
  IsStackIndexLessThan(n, m+n_in),
  BeforeLocalStackContents(stmt, n, varOrStackIndex).

// TODO, check case for function return
FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
  Function_Return(func, retBlock),
  NumberOfFunctionReturnArguments(func, n_out),
  BasicBlock_Tail(retBlock, stmt),
  Statement_Opcode(stmt, opcode),
  OpcodePopWords(opcode, m),
  IsStackIndexLessThan(n, m+n_out),
  BeforeLocalStackContents(stmt, n, varOrStackIndex).

FunctionalStatement_Uses_Local(stmt, varOrStackIndex, n) :-
   Statement_Uses_Local(stmt, varOrStackIndex, n).

FunctionalStatement_Uses(stmt, var, n) :-
   Statement_Uses_Local(stmt, var, n),
   CheckIsVariable(var).

FunctionalStatement_Defines(stmt, newVar, 0) :- Statement_Defines(stmt, newVar).

// Case: variable originates elsewhere
FunctionalStatement_Uses(stmt, var, n) :-
   Statement_Uses_Local(stmt, stackIndex, n),
   CheckIsStackIndex(stackIndex),
   Statement_Block(stmt, block),
   FunctionalBlockInputContents(block, stackIndex, var).

.output FunctionalBlockInputContents
.output FunctionalBlockOutputContents
