/******
         Heuristics for discovering public functions
******/
// Special entry point to public function found heuristically
.decl PublicFunctionEntry(basicBlock: Block, sigHash: Value)
// Code inserted by compiler to dispatch to the correct public function
.decl PublicFunctionDispatcher(basicBlock: Block, sigHash: Value)
// (Possibly) Code inserted by compiler to compare function signature
.decl BlockComparesSig(block: Block, sigHash: Value)

BlockComparesSig(block, sigHash) :-
  Statement_Block(pushStmt, block),
  PUSH4(pushStmt, sigHash),
  Statement_Defines(pushStmt, sigHashVar),
  Statement_Block(eqStmt, block),
  EQ(eqStmt),
  Statement_Uses(eqStmt, sigHashVar, _),
  Statement_Block(jumpiStmt, block),
  JUMPI(jumpiStmt),
  Statement_Defines(eqStmt, pred),
  Statement_Uses(jumpiStmt, pred, 1).
   
// Initial case, uses CALLDATALOAD
PublicFunctionDispatcher(block, sigHash) :-
  Statement_Block(stmt, block),
  CALLDATALOAD(stmt),
  BlockComparesSig(block, sigHash).

// General case
PublicFunctionDispatcher(block, sigHash) :-
  BlockComparesSig(block, sigHash),
  BlockEdge(_, prev, _, block),
  PublicFunctionDispatcher(prev, _).

PublicFunctionEntry([stmt], sigHash) :-
  PublicFunctionDispatcher(block, sigHash),
  Statement_Block(jumpiStmt, block),
  JUMPI(jumpiStmt),
  BeforeLocalStackContents(jumpiStmt, _, labelvar),
  Variable_Value(labelvar, label),
  IsBasicBlockHead(stmt),
  ord(label) = ord(stmt).

/******
         Generic Reachable-from implementation
******/


.decl ReachableFrom(block:Block, from:Block)

ReachableFrom(block, block) :- Statement_Block(_, block).


ReachableFrom(blockNext, blockPrev) :-
   ReachableFrom(block, blockPrev),
   BlockEdge(_, block, _, blockNext). 


/******
         Heuristics for detecting call-return patterns
******/

.decl PossibleReturnAddress(caller:Block, ret:Block, target:Block)

// Possibly a return:
// a) basic block jumps to a valid "non-locally-derived" address
// b) address originates at a caller that can reach the
//    returning basic block.
PossibleReturnAddress(callerBlock, retBlock, target) :-
  BlockJumpValidTarget(_, retBlock, targetVariable, target),
  BasicBlock_Tail(callerBlock, callerStmt),
  callerBlock != retBlock,
  IsJump(callerStmt),
  Statement_Defines(otherCallerStatement, targetVariable),
  Statement_Block(otherCallerStatement, callerBlock).


.decl PossibleFunctionCall(caller:Block, func:Block, retBlock:Block, retTarget:Block)

PossibleFunctionCall(caller, func, retBlock, retTarget) :-
  PossibleReturnAddress(caller, retBlock, retTarget),
  BlockJumpValidTarget(_, caller, _, func).

.decl PossiblyInFunction(block:Block, func:Block)

// Which basic blocks belong to which function
PossiblyInFunction(func, func) :-
   PossibleFunctionCall(_, func, _, _).

// In this case we're moving onto another function
PossiblyInFunction(next, func) :-
   PossiblyInFunction(block, func),
   BlockEdge(_, block, _, next),
   !PossibleFunctionCall(block, _, _, _).

// In this case we're return from a function we've just called
PossiblyInFunction(retTarget, func) :-
   PossiblyInFunction(block, func),
   PossibleFunctionCall(block, _, _, retTarget).

// What is a function?
// A function has to have a single entry point

.decl NotRegularFunction(func:Block)

// A basic block can only belong to a single function
// Solution: Pick one!
NotRegularFunction([func2]) :-
  PossiblyInFunction(block, [func1]),
  PossiblyInFunction(block, [func2]),
  ord(func1) > ord(func2).

// A function can only be entered by calling it
NotRegularFunction(func) :-
  PossiblyInFunction(_, func),
  BlockEdge(_, caller, _, func),
  !PossibleFunctionCall(caller, func, _, _).


.decl FunctionCallReturn(caller:Block, func:Block, retTarget:Block)
.decl Function_Return(func:Block, retBlock:Block)

Function_Return(func, retBlock),
FunctionCallReturn(caller, func, retTarget) :-
   PossibleFunctionCall(caller, func, retBlock, retTarget),
   !NotRegularFunction(func).


// Further function decomposition

// Used components to force stratification.
// Detects function boundaries, calls and returns
// in an iterative fashion

.comp FunctionDetection {
  // An Entry to a function (private or public)
  .decl FunctionEntry(block: Block)
  // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionEntry(block: Block)

  // Basic block belongs to function
  .decl InFunction(block: Block, function: Block)
  // Basic block performs a function call 
  .decl FunctionCall(block: Block, func: Block)
   // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionCall(block: Block, func: Block)

  InFunction(block, block) :-
    PrevFunctionEntry(block).

  InFunction(next, func) :-
    InFunction(block, func),
    BlockEdge(_, block, _, next),
    !PrevFunctionCall(block, next),
    !Function_Return(_, block).

 InFunction(next, func) :-
   InFunction(block, func),
   FunctionCallReturn(block, _, next).

  // Heuristic for finding function calls
  // Execution flows to a basic block that is
  // part of more than one function, TODO
  FunctionCall(prev, block),
  FunctionEntry(block) :-
    InFunction(block, func1),
    InFunction(block, func2),
    func1 != func2,
    BlockEdge(_, prev, _, block),
    !Function_Return(_, prev),
    !(InFunction(prev, func1), InFunction(prev, func2)).

  FunctionCall(prev, func1) :- PrevFunctionCall(prev, func1).
}

// Initialise and iterate the algorithm
.init detector0 = FunctionDetection
detector0.PrevFunctionEntry(block) :-
   PublicFunctionEntry(block, _).
detector0.PrevFunctionEntry(block) :-
   FunctionCallReturn(_, block, _).

detector0.PrevFunctionCall(prev, func) :-
  PublicFunctionEntry(func, sigHash),
  PublicFunctionDispatcher(prev, sigHash).

detector0.PrevFunctionCall(prev, func) :-
   FunctionCallReturn(prev, func, _).
  
.init detector1 = FunctionDetection
detector1.PrevFunctionEntry(block) :- detector0.FunctionEntry(block).
detector1.PrevFunctionCall(block, func) :- detector0.FunctionCall(block, func).

.init detector2 = FunctionDetection
detector2.PrevFunctionEntry(block) :- detector1.FunctionEntry(block).
detector2.PrevFunctionCall(block, func) :- detector1.FunctionCall(block, func).

/***********
   Collecting all function decomposition results
***********/

.decl FunctionCall(block:Block, func:Block)

// Case 1: private call return
FunctionCall(block, func) :- FunctionCallReturn(block, func, _).

// Case 2: dispatch public functions
FunctionCall(block, func) :-
  PublicFunctionEntry(func, sigHash),
  PublicFunctionDispatcher(block, sigHash).

// Case 3: further decomposition using components
FunctionCall(block, func) :-
   detector0.FunctionCall(block, func) ;
   detector1.FunctionCall(block, func) ;
   detector2.FunctionCall(block, func).

.decl Function(func:Block)

// Case 1: Smart contract entry
Function(["0x0"]).

// Remaining cases handled by inputs/outputs of componenets
Function(func) :-
   detector0.PrevFunctionEntry(func) ;
   detector0.FunctionEntry(func) ;
   detector1.FunctionEntry(func) ;
   detector2.FunctionEntry(func).


/***********
   Final outputs to visualization scripts
***********/
 

.decl FunctionCall_Out(caller:symbol, func:symbol)
.output FunctionCall_Out

FunctionCall_Out(caller, func) :-
  FunctionCall([caller], [func]).

.decl FunctionCallReturn_Out(caller:symbol, func:symbol, retTarget:symbol)
.output FunctionCallReturn_Out
        
.decl Function_Return_Out(func:symbol, retBlock:symbol)
.output Function_Return_Out

.decl Function_Out(func: symbol)
.output Function_Out

FunctionCallReturn_Out(caller, func, retTarget) :-
  FunctionCallReturn([caller], [func], [retTarget]).

Function_Out(func) :- Function([func]).

Function_Return_Out(func, retBlock) :-
   Function_Return([func], [retBlock]).


.decl LocalBlockEdge(block: Block, next: Block)

LocalBlockEdge(block, next) :-
  BlockEdge(_, block, _, next),
  !Function(next),
  !Function_Return(_, block).

LocalBlockEdge(block, next) :-
  BlockEdge(_, block, _, func),
  FunctionCallReturn(block, func, next).

// New Instructions
// CALLPRIVATE(stmt, function)
// CALLPRIVATEI(stmt, cond, function)
// RETURNPRIVATE(stmt)
// RETURNPRIVATEI(stmt, cond)

// Compute stack deltas for arguments
// We only do this for functions that return
.decl BlockFunctionStackDelta(block: Block, delta: number)

// Base case
BlockFunctionStackDelta(block, delta) :-
   FunctionCallReturn(_, block, _),
   BlockStackDelta(block, delta).

// General, no function call
BlockFunctionStackDelta(next, newDelta) :-
  BlockFunctionStackDelta(block, delta),
  LocalBlockEdge(block, next),
  BlockStackDelta(next, delta2),
  !FunctionCallReturn(block, _, _),
  newDelta = delta+delta2,
  newDelta < MAX_STACK_HEIGHT,
  -newDelta < MAX_STACK_HEIGHT.

// General, w/ function call
BlockFunctionStackDelta(next, delta+delta2+delta3) :-
  BlockFunctionStackDelta(block, delta),
  LocalBlockEdge(block, next),
  BlockStackDelta(next, delta2),
  FunctionCallReturn(block, function, _),
  FunctionStackDelta(function, delta3),
  newDelta = delta+delta2+delta3,
  newDelta < MAX_STACK_HEIGHT,
  -newDelta < MAX_STACK_HEIGHT.

.decl NotBalancedFunction(function: Block)

NotBalancedFunction(function) :-
   Function_Return(function, ret1),
   Function_Return(function, ret2),
   BlockFunctionStackDelta(ret1, delta1),
   BlockFunctionStackDelta(ret2, delta2),
   delta1 != delta2.

.decl FunctionStackDelta(function: Block, delta: number)

FunctionStackDelta(function, delta) :-
   Function_Return(function, ret),
   !NotBalancedFunction(function),
   BlockFunctionStackDelta(ret, delta).
   
.decl BlockFunctionPopDelta(block: Block, delta: number)

// Base case
BlockFunctionPopDelta(block, delta) :-
   Function(block),
   BlockPopDelta(block, delta).

BlockPopDeltaWithFunctionCall(block, delta) :-
  BlockPopDelta(block, delta),
  BlockEdge(_, block, _, next),
  !Function_Return(next, _).

BlockPopDeltaWithFunctionCall(block, functionPopDelta - stackDelta) :-
  BlockPopDelta(block, popDelta),
  BlockStackDelta(block, stackDelta),
  FunctionCallReturn(block, function, _),
  FunctionStackDelta(function, functionStackDelta),
  FunctionPopDelta(function, functionPopDelta),
  functionPopDelta - stackDelta > stackDelta.

// Other case
//StatementPopDelta(stmt, prevPopDelta) :-
//  StatementStackDelta(prevstmt, prevStackDelta),
//  StatementPopDelta(prevstmt, prevPopDelta),
//  !IsBasicBlockTail(prevstmt),
//  Statement_Next(prevstmt, stmt),
//  Statement_Opcode(stmt, opcode),
//  OpcodePopWords(opcode, popdelta),
//  popdelta - prevStackDelta <= prevPopDelta.


// General, no function call
BlockFunctionPopDelta(next, delta+delta2) :-
  BlockFunctionStackDelta(block, delta),
  LocalBlockEdge(block, next),
  BlockPopDelta(next, delta2),
  !FunctionCallReturn(block, _, _).



