// Special entry point to public function found heuristically
.decl PublicFunctionEntry(basicBlock: Block, sigHash: Value)
// Code inserted by compiler to dispatch to the correct public function
.decl PublicFunctionDispatcher(basicBlock: Block, sigHash: Value)
// (Possibly) Code inserted by compiler to compare function signature
.decl BlockComparesSig(block: Block, sigHash: Value)

// TODO: Can be strengthened by checking for flow
BlockComparesSig(block, sigHash) :-
  Stmt_BasicBlock(pushStmt, block),
  PUSH4(pushStmt, sigHash),
  Stmt_BasicBlock(eqStmt, block),
  EQ(eqStmt),
  BeforeLocalStackContents(eqStmt, _, MAKE_VALUE(sigHash)),
  //Statement_Next(eqStmt, jumpiStmt), 
  Stmt_BasicBlock(jumpiStmt, block),
  JUMPI(jumpiStmt).
   
// Initial case, uses CALLDATALOAD
PublicFunctionDispatcher(block, sigHash) :-
  Stmt_BasicBlock(stmt, block),
  CALLDATALOAD(stmt),
  BlockComparesSig(block, sigHash).

// General case
PublicFunctionDispatcher(block, sigHash) :-
  BlockComparesSig(block, sigHash),
  BlockEdge(_, prev, _, block),
  PublicFunctionDispatcher(prev, _).

PublicFunctionEntry([stmt], sigHash) :-
  PublicFunctionDispatcher(block, sigHash),
  Stmt_BasicBlock(jumpiStmt, block),
  JUMPI(jumpiStmt),
  BeforeLocalStackContents(jumpiStmt, _, MAKE_VALUE(label)),
  IsBasicBlockHead(stmt),
  ord(label) = ord(stmt).

// Used components to break recursion through negation problem
// we are trying to solve. Detects function boundaries, calls and returns
// in an iterative fashion

.comp FunctionDetection {
   // An Entry to a function (private or public)
   .decl FunctionEntry(block: Block)
   // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionEntry(block: Block)

  // Basic block belongs to function
  .decl InFunction(block: Block, function: Block)
  // Basic block performs a function call 
  .decl FunctionCall(block: Block, func: Block)
   // Same, but for previous iteration of the algorithm   
  .decl PrevFunctionCall(block: Block, func: Block)
  // Basic block returns computation back to the supplied continuation
  .decl PossibleFunctionReturn(block: Block, func: Block, target1: Value)
  .decl NotFunctionReturn(block: Block, func: Block)
  .decl FunctionReturn(block: Block, func: Block)

  InFunction(block, block) :-
    PrevFunctionEntry(block).

  InFunction(next, func) :-
    InFunction(block, func),
    BlockEdge(_, block, _, next),
    !PrevFunctionCall(block, next).

  // Heuristic for finding return instructions
  // 1. jumps to a polymorphic target
  // 2. target address supplied to the function (originates in the caller)
  PossibleFunctionReturn(block, func, target2),
  PossibleFunctionReturn(block, func, target1) :-
    BlockJumpValidTarget(_, block, target1),
    BlockJumpValidTarget(_, block, target2),
    target1 != target2,
    InFunction(block, func).

  NotFunctionReturn(block, func) :-
    PossibleFunctionReturn(block, func, target1),
    !BlockInputContents(_, func, _, target1).

  FunctionReturn(block, func) :-
   PossibleFunctionReturn(block, func, _),
   !NotFunctionReturn(block, func).

  // Heuristic for finding function calls
  // Execution flows to a basic block that is
  // part of more than one function, TODO
  FunctionCall(prev, block),
  FunctionEntry(block) :-
    InFunction(block, func1),
    InFunction(block, func2),
    func1 != func2,
    BlockEdge(_, prev, _, block),
    !InFunction(prev, func1),
    !FunctionReturn(prev, _).

  FunctionCall(prev, func1) :- PrevFunctionCall(prev, func1).
}

// Initialise and iterate the algorithm
.init detector0 = FunctionDetection
detector0.PrevFunctionEntry(block) :-
  PublicFunctionEntry(block, _).
detector0.PrevFunctionCall(prev, func) :-
  PublicFunctionEntry(func, sigHash),
  PublicFunctionDispatcher(prev, sigHash).
  
.init detector1 = FunctionDetection
detector1.PrevFunctionEntry(block) :- detector0.FunctionEntry(block).
detector1.PrevFunctionCall(block, func) :- detector0.FunctionCall(block, func).

.init detector2 = FunctionDetection
detector2.PrevFunctionEntry(block) :- detector1.FunctionEntry(block).
detector2.PrevFunctionCall(block, func) :- detector1.FunctionCall(block, func).

.decl FunctionEntryOut(block: Statement)


// Collect results of function detection algorithm
FunctionEntryOut(stmt) :-
   detector0.PrevFunctionEntry([stmt]) ;
   detector0.FunctionEntry([stmt]) ;
   detector1.FunctionEntry([stmt]) ;
   detector2.FunctionEntry([stmt]).

FunctionEntryOut("0x0").
.output FunctionEntryOut

.decl FunctionCallOut(block: Statement, func: Statement)
.output FunctionCallOut

FunctionCallOut(block, func) :-
   detector2.FunctionCall([block], [func]).

.decl FunctionReturnOut(block: Statement, func: Statement)
.output FunctionReturnOut
FunctionReturnOut(block, func) :-        
   detector0.FunctionReturn([block], [func]) ;
   detector1.FunctionReturn([block], [func]) ;
   detector2.FunctionReturn([block], [func]).

