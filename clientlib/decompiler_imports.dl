// The parts of the schema of the decompiler output that need to be
// imported in order to import the full three-address code
// intermediate representation. All the information is there, but this
// code, together with tac_instructions.dl, creates a different
// intermediate representation (often reusing instruction names).

.type Variable
.type Statement
.type Block
.type Function
.type Opcode
.type Value

#include "tac_instructions.dl"

.decl OpcodePossiblyHalts(op: Opcode)
.input OpcodePossiblyHalts(IO="file", filename="OpcodePossiblyHalts.csv", delimiter="\t")

// Final decompiler outputs, code

// 1 to 1 relation from statements to Opcodes.
// Some of the opcodes are identical to the opcodes produced by EVM.
.decl Statement_Opcode(stmt:Statement, op:Opcode)
.input Statement_Opcode(IO="file", filename="TAC_Op.csv", delimiter="\t")

// All the Statements.
// Most statement ids correspond to actual program locations in the original code.
.decl IsStatement(stmt:Statement)
.input IsStatement(IO="file", filename="TAC_Stmt.csv", delimiter="\t")

// All the Variables
// Some variable ids correspond to statement ids where the variable
// is originally defined, but some don't e.g. formal arguments.
.decl IsVariable(var: Variable)
.input IsVariable(IO="file", filename="TAC_Var.csv", delimiter="\t")

// Maps statements to their basic block. Note that:
// a) A statement can (and has to) pertain to *one* basic block.
// b) A basic block may be empty.
// c) As the type system suggests, basic blocks ids *do not*
//    correspond to statement ids.
.decl Statement_Block(stmt: Statement, block: Block)
.input Statement_Block(IO="file", filename="TAC_Block.csv", delimiter="\t")

// Value which a variable may have. Concrete values only.
.decl Variable_Value(var: Variable, value: Value)
.input Variable_Value(IO="file", filename="TAC_Variable_Value.csv", delimiter="\t")

// Value length in bytes which a variable may have.
.decl Variable_Length(var: Variable, length: number)
.input Variable_Length(IO="file", filename="TAC_Variable_Length.csv", delimiter="\t")

// Control flow & functions

// As the name suggests, is an intra-procedural CFG.
.decl LocalBlockEdge(block: Block, nextBlock: Block)
.input LocalBlockEdge(IO="file", filename="LocalBlockEdge.csv", delimiter="\t")

// A subset of LocalBlockEdge, corresponds to fallthrough edges of conditional jumps.
.decl FallthroughEdge(block: Block, nextBlock: Block)
.input FallthroughEdge(IO="file", filename="IRFallthroughEdge.csv", delimiter="\t")

.decl CallGraphEdge(block: Block, function: Function)
.input CallGraphEdge(IO="file", filename="IRFunctionCall.csv", delimiter="\t")

// Represents part of the callgraph for functions that are called and which return
// control flow back to the caller.
.decl FunctionCallReturn(block: Block, function: Function, return: Block)
.input FunctionCallReturn(IO="file", filename="IRFunctionCallReturn.csv", delimiter="\t")

// All the functions, function ids do *not* correspond to the entry point block
// of said function
.decl IsFunction(func: Function)
.input IsFunction(IO="file", filename="Function.csv", delimiter="\t")

// A subset of IsFunction, represents public functions. All the rest of the functions
// are private functions.
.decl IsPublicFunction(func: Function)
.input IsPublicFunction(IO="file", filename="PublicFunction.csv", delimiter="\t")

// Name given to each function. May contain public signature too.
// Useful for presentation purposes.
.decl HighLevelFunctionName(func: Function, name: symbol)
.input HighLevelFunctionName(IO="file", filename="HighLevelFunctionName.csv", delimiter="\t")

// Special instructions & data flow

// Actuals are on the function call side, the args supplied to a function call
.decl ActualArgs(caller: Block, a: Variable, pos: number)

ActualArgs(caller, a, pos - 1) :-
   Statement_Uses(s, a, pos),
   CALLPRIVATE(s, _),
   pos >= 1,
   Statement_Block(s, caller).

ActualArgs(caller, a, pos - 2) :-
   Statement_Uses(s, a, pos),
   CALLPRIVATEI(s, _, _),
   pos >= 2,
   Statement_Block(s, caller).

// Actual returns are on the function call side
.decl ActualReturnArgs(caller: Block, a: Variable, pos: number)
.input ActualReturnArgs(IO="file", filename="ActualReturnArgs.csv", delimiter="\t")

// formal return args are on the function definition side
.decl FormalReturnArgs(fn: Function, a: Variable, pos: number)
FormalReturnArgs(fn, a, pos - 1) :-
   Statement_Uses(s, a, pos),
   RETURNPRIVATE(s, _),
   pos >= 1,
   Statement_Block(s, b),
   InFunction(b, fn).

FormalReturnArgs(fn, a, pos - 2) :-
   Statement_Uses(s, a, pos),
   RETURNPRIVATEI(s, _, _),
   pos >= 2,
   Statement_Block(s, b),
   InFunction(b, fn).


.decl FormalArgs(fn: Function, a: Variable, pos: number)
.input FormalArgs(IO="file", filename="FormalArgs.csv", delimiter="\t")


.decl Statement_Uses(stmt: Statement, var: Variable, i: number)
.input Statement_Uses(IO="file", filename="TAC_Use.csv", delimiter="\t")
.decl Statement_Defines(stmt: Statement, var: Variable, n: number)
.input Statement_Defines(IO="file", filename="TAC_Def.csv", delimiter="\t")


// A total order which models all instructions except PHI instructions.
// PHI instrucions do not appear in this relation.
.decl Statement_Next(stmt: Statement, next: Statement)
.input Statement_Next(IO="file", filename="TAC_Statement_Next.csv", delimiter="\t")


// Basic block corresponding to the function's entry point
.decl FunctionEntry(block: Block)
.input FunctionEntry(IO="file", filename="IRFunctionEntry.csv", delimiter="\t")

// Basic block corresponding to a function's exit points
.decl FunctionExit(block: Block)
FunctionExit(block) :-
   LocalBlockEdge(_, block),
   !LocalBlockEdge(block, _).

.decl CastBlockToFunction(block: symbol)
CastBlockToFunction(block) :- FunctionEntry(block).

// Whether a block is in a function
// Currently, blocks may in some cases be part of multiple functions
.decl InFunction(block: Block, function: Function)
.input InFunction(IO="file", filename="InFunction.csv", delimiter="\t")

.decl GlobalBlockEdge(block: Block, next: Block)

GlobalBlockEdge(block, next) :-
   LocalBlockEdge(block, next),
   !FunctionCallReturn(block, _, next).

GlobalBlockEdge(block, next) :-
   CallGraphEdge(block, function),
   InFunction(next, function),
   FunctionEntry(next).

GlobalBlockEdge(returnBlock, next) :-
   FunctionCallReturn(_, function, next),
   InFunction(returnBlock, function),
   Statement_Block(s, returnBlock),
   (RETURNPRIVATE(s, _) ; RETURNPRIVATEI(s, _, _)).

.decl LocalReachableFrom(from: Block, next: Block)
LocalReachableFrom(from, next) :-
  LocalBlockEdge(from, next).

LocalReachableFrom(from, to) :-
  LocalReachableFrom(next, to),
  LocalBlockEdge(from, next).


.decl NotTailStatement(s: Statement)

NotTailStatement(s) :-
   Statement_Block(s, b),
   Statement_Next(s, n),
   Statement_Block(n, b).

// Last statement in a basic block
.decl Block_Tail(b: Block, t: Statement)

Block_Tail(b, t) :-
   Statement_Block(t, b),
   !NotTailStatement(t).

.decl IsBlock(b: Block)

IsBlock(b) :-
  Statement_Block(_, b).

.decl Mask_Length(mask: Value, bytes: number)
.input Mask_Length(IO="file", filename="Mask_Length.csv", delimiter="\t")
